<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><!-- Font preloads --><!-- <link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin /> --><!-- <link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin /> --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/distributed-system-observability-complete-end-to-end-example-with-opentracing-jaeger-prometheus-grafana-spring-boot-react-and-selenium/"><!-- Primary Meta Tags --><title>Distributed system observability: complete end-to-end example with OpenTracing, Jaeger, Prometheus, Grafana, Spring Boot, React and Selenium</title><meta name="title" content="Distributed system observability: complete end-to-end example with OpenTracing, Jaeger, Prometheus, Grafana, Spring Boot, React and Selenium"><meta name="description" content="Code examples and explanations on an end-to-end example showcasing a distributed system observability from the Selenium tests through React front end, all the way to the database calls of a Spring Boot application. Examples are implemented with the OpenTracing toolset and traces are saved in Jaeger. This example also shows a complete observability setup including tools like Grafana, Prometheus, Loki, and Promtail."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/distributed-system-observability-complete-end-to-end-example-with-opentracing-jaeger-prometheus-grafana-spring-boot-react-and-selenium/"><meta property="og:title" content="Distributed system observability: complete end-to-end example with OpenTracing, Jaeger, Prometheus, Grafana, Spring Boot, React and Selenium"><meta property="og:description" content="Code examples and explanations on an end-to-end example showcasing a distributed system observability from the Selenium tests through React front end, all the way to the database calls of a Spring Boot application. Examples are implemented with the OpenTracing toolset and traces are saved in Jaeger. This example also shows a complete observability setup including tools like Grafana, Prometheus, Loki, and Promtail."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder-1.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/distributed-system-observability-complete-end-to-end-example-with-opentracing-jaeger-prometheus-grafana-spring-boot-react-and-selenium/"><meta property="twitter:title" content="Distributed system observability: complete end-to-end example with OpenTracing, Jaeger, Prometheus, Grafana, Spring Boot, React and Selenium"><meta property="twitter:description" content="Code examples and explanations on an end-to-end example showcasing a distributed system observability from the Selenium tests through React front end, all the way to the database calls of a Spring Boot application. Examples are implemented with the OpenTracing toolset and traces are saved in Jaeger. This example also shows a complete observability setup including tools like Grafana, Prometheus, Loki, and Promtail."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder-1.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:calc(100% - 2em);margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
article[data-astro-cid-bvzihdzo]{padding:24px;box-shadow:0 2px 3px #acabab;background:#fff;position:relative}.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2021-10-13T00:00:00.000Z"> Oct 13, 2021 </time> <div class="last-updated-on" data-astro-cid-bvzihdzo>
Last updated on <time datetime="2022-01-18T00:00:00.000Z"> Jan 18, 2022 </time> </div> </div> <h1 class="post-title" data-astro-cid-bvzihdzo>Distributed system observability: complete end-to-end example with OpenTracing, Jaeger, Prometheus, Grafana, Spring Boot, React and Selenium</h1> <hr data-astro-cid-bvzihdzo> </div>  <p><span>This post is part of Distributed system observability: complete end-to-end example</span><span> series. The code used for this series of blog posts is located in </span><a href="https://github.com/llatinov/selenium-observability-java" target="_blank" rel="noopener noreferrer">selenium-observability-java</a><span> GitHub repository.</span></p>
<h2>Introduction</h2>
Nowadays, the <a href="https://microservices.io/patterns/microservices.html" target="_blank" rel="noopener">MIcroservices architecture</a> is very popular. It certainly has its benefits, allowing the companies to deliver faster products to the market. It is much easier to manage several small applications, each one of them with isolated responsibilities, rather than one big fat monolithic application. Microservices architecture has its challenges as well. One of those challenges is traceability. What happens in case of error, where did it occur, what microservices were involved, what were the requests flow through the system, where is the stack trace? In a monolithic application, the stack trace is shown into the logs, giving the exact location of the error. In a microservices landscape, errors are in many cases meaningless, unless there is full traceability of the request flow.
<h2>Observability and distributed tracing</h2>
Distributed tracing, also called distributed request tracing, is a method used to profile and monitor applications, especially those built using a microservices architecture. Distributed tracing helps pinpoint where failures occur and what causes poor performance. Logs, metrics, and traces are often known as the three pillars of observability. Further reading on observability can be done in <a href="https://www.oreilly.com/library/view/distributed-systems-observability/9781492033431/ch04.html" target="_blank" rel="noopener">The Three Pillars of Observability</a> article.
<h2>OpenTracing</h2>
<a href="https://opentracing.io/docs/overview/what-is-tracing/" target="_blank" rel="noopener">OpenTracing</a> is an API specification and libraries, that enables the instrumentation of distributed applications. It is not locked to any particular vendors and allows flexibility just by changing the configuration of already instrumented applications. More details can be found in <a href="https://opentracing.io/docs/best-practices/instrumenting-your-application/" target="_blank" rel="noopener">Instrumenting your application</a> and <a href="https://opentelemetry.lightstep.com/tracing/" target="_blank" rel="noopener">What is Distributed Tracing?</a>. Current examples are based on OpenTracing libraries and tools.
<h2>End-to-end traceability and observability</h2>
In the current examples, I am going to give an end-to-end solution, how observability can be achieved in a distributed system. I have used <a href="https://github.com/mnadeem/boot-opentelemetry-tempo" target="_blank" rel="noopener">mnadeem/boot-opentelemetry-tempo</a> project as a basis and have extended it with React Frontend and Selenium tests, to provide a complete end-to-end example. Below is a diagram of the full setup. All applications involved will be explained on a higher level.
<img src="/images/2021/10/Selenium-Observability-architecture-diagram.png">
<h3>PostgreSQL and pgAdmin</h3>
The basic examples used <a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL</a>, I thought of changing it to MySQL, but when I did short research, I found that PostgreSQL has some advantages. PostgreSQL <span>is an object-relational database, while MySQL is a purely relational database. This means that Postgres includes features like table inheritance and function overloading, which can be important to certain applications. Postgres also adheres more closely to SQL standards. See more in <a href="https://developer.okta.com/blog/2019/07/19/mysql-vs-postgres" target="_blank" rel="noopener">MySQL vs PostgreSQL -- Choose the Right Database for Your Project</a>.</span>
<p><a href="https://www.pgadmin.org/" target="_blank" rel="noopener">pgAdmin</a> is the default user interface to manage a PostgreSQL database, so it is present in the architecture as well.</p>
<h3>Spring Boot backend</h3>
<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a> is used as a backend. I did want to get some exposure to the technology, so I created a very basic application in Spring Boot. It uses the PostgreSQL database for reading and writing data. Spring Boot application is instrumented with OpenTelemetry Java library and exports the traces in Jaeger format directly to the Jaeger backend. It also writes application log files on a file system. Backend exposes APIs, which are consumed by the frontend. More details on the backend can be found in <a href="/distributed-system-observability-instrument-spring-boot-application-with-opentelemetry/">Distributed system observability: Instrument Spring Boot application with OpenTelemetry</a> post.
<h3>React frontend</h3>
I am very experienced with <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>, so this was the natural choice for the frontend technology. The frontend uses <em><strong>fetch()</strong></em> to consume the backend APIs. It is instrumented with OpenTelementry JavaScript libraries to trace all communication happening through fetch() and to exports the traces in OpenTelemetry format to the OpenTelemetry collector. The frontend also has manual instrumentation which traces the actions done by end-users on it. More details on the frontend can be found in <a href="/distributed-system-observability-instrument-react-application-with-opentelemetry/">Distributed system observability: Instrument React application with OpenTelemetry</a> post.
<h3>OpenTelemetry collector</h3>
<a href="https://github.com/open-telemetry/opentelemetry-collector" target="_blank" rel="noopener">OpenTelemetry collector</a> converts the data received from the frontend in OpenTelemetry format into Jaeger format and exports it to the Jaeger backend. The collector is also extracting the span metrics, which are read by Prometheus, read more in <a href="/distributed-system-observability-extract-and-visualize-metrics-from-opentelemetry-spans/">Distributed system observability: extract and visualize metrics from OpenTelemetry spans</a> post. Configurations are described in the <a href="https://opentelemetry.io/docs/collector/configuration/" target="_blank" rel="noopener">collector configuration</a>. Local configurations are in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/otel-config.yaml" target="_blank" rel="noopener">otel-config.yaml</a>.
<h3>Selenium tests</h3>
<a href="https://www.selenium.dev/" target="_blank" rel="noopener">Selenium</a> was chosen for the web testing framework because of its <a href="https://www.selenium.dev/documentation/grid/advanced_features/observability/" target="_blank" rel="noopener">observability</a> feature. Actually, this was the reason for which I created the current examples. After getting to know the tracing features of Selenium better, I find them not much useful. Selenium does not provide traceability of the tests, but rather on its internal operations and performance. Having started with the tracing and the whole project, I could not ditch it in the middle, so I have to create a custom way to make Selenium trace the tests. Selenium tests export tracing information in Jaeger format directly into the Jaeger backend. More details on the tests can be found in <a href="/distributed-system-observability-instrument-selenium-tests-with-opentelemetry/">Distributed system observability: Instrument Selenium tests with OpenTelemetry</a> post.
<h3>Cypress tests</h3>
<a href="https://docs.cypress.io/guides/overview/why-cypress" target="_blank" rel="noopener">Cypress</a> is a front-end testing tool built for the modern web. It is most often compared to Selenium. The initial driver of the current post series was Selenium observability. After I got a better understanding of the observability topic, I've decided to add examples on Cypress tests observability for more completeness of the examples. Cypress interacts with the Frontend and exports its traces to OpenTelemetry Collector, which then forwards the traces into Jaeger. More details on the tests can be found in <a href="/distributed-system-observability-instrument-cypress-tests-with-opentelemetry/">Distributed system observability: Instrument Cypress tests with OpenTelemetry</a> post.
<h3>Jaeger</h3>
<a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jaeger</a>, inspired by Dapper and OpenZipkin, is an open-source distributed tracing system. It is used for monitoring and troubleshooting microservices-based distributed systems. Jaeger collects all the traces and provides a search and visualization of the traces. In the original examples, <a href="https://grafana.com/docs/tempo/latest/getting-started/" target="_blank" rel="noopener">Grafana Tempo</a> was used as a backend and <a href="https://www.jaegertracing.io/docs/1.26/frontend-ui/" target="_blank" rel="noopener">Jaeger UI</a> via the <a href="https://www.jaegertracing.io/docs/1.26/deployment/" target="_blank" rel="noopener">jaeger-query</a> module to open the traces. I initially started with it, but Tempo does not provide a possibility to search the traces. I find this rather inconvenient, so I switched completely to Jaeger.
<h3>Promtail</h3>
<a href="https://grafana.com/docs/loki/latest/clients/promtail/" target="_blank" rel="noopener">Promtail</a> is <span>an agent which ships the contents of the Spring Boot backend logs to a Loki instance</span><span>. It is usually deployed to every machine that has applications needed to be monitored. Local configurations are in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/promtail-local.yaml" target="_blank" rel="noopener">promtail-local.yaml</a>.</span>
<h3>Loki</h3>
<a href="https://grafana.com/oss/loki/" target="_blank" rel="noopener">Grafana Loki</a> is <span>a log aggregation system inspired by Prometheus. It does not index the contents of the logs, but rather a set of labels for each log stream. Log data itself is then compressed and stored in chunks. In the current example, logs are being pushed to Loki by Promtrail. Local configurations are in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/loki-local.yaml" target="_blank" rel="noopener">loki-local.yaml</a>.</span>
<h3>Prometheus</h3>
<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> is an open-source monitoring and alerting toolkit. Prometheus collects and stores its metrics as time-series data, i.e. metrics information is stored with the timestamp at which it was recorded, alongside optional key-value pairs called labels. In the current example, Prometheus is monitoring the Sprint Boot backend, Loki, Jaeger, and OpenTelemetry Collector. It pulls the metrics data from those applications at a regular interval and stores them in its database. Alerts can be configured based on the metrics. Local configurations are in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/prometheus.yaml" target="_blank" rel="noopener">prometheus.yaml</a>.
<h3>Grafana</h3>
<a href="https://grafana.com/grafana/" target="_blank" rel="noopener">Grafana</a> is an open-source solution for running data analytics, pulling up metrics from different data sources, and monitoring applications with the help of customizable dashboards. The tool helps to study, analyze and monitor data over a period of time, technically called time-series analytics. In the current example, Grafana pulls data from Prometheus, Jaeger, and Loki. Local configurations are in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/grafana-dashboards.yaml" target="_blank" rel="noopener">grafana-dashboards.yaml</a> and <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/grafana-datasource.yml" target="_blank" rel="noopener">grafana-datasource.yml</a>.
<h2>Explore the example</h2>
Running the example is very easy. What is needed is Docker compose and IDE that can run JUnit tests, I prefer IntelliJ IDEA. Run the examples:
<ol>
 	<li>Check out the source code from <a href="https://github.com/llatinov/selenium-observability-java" target="_blank" rel="noopener">https://github.com/llatinov/selenium-observability-java</a></li>
 	<li>Run: docker-compose build</li>
 	<li>Run: docker-compose up</li>
 	<li>Open selenium-tests Maven project and run all the unit tests</li>
</ol>
Explore the example artifacts:
<h3>pgAdmin</h3>
pgAdmin is accessible at <a href="http://localhost:8005/" target="_blank" rel="noopener">http://localhost:8005/</a>. In order to log in, use the following credentials: <span><span>pgadmin4@pgadmin.org / </span></span>admin. This is needed only if the database records have to be read or modified.
<h3>Jaeger</h3>
Jaeger is accessible at <a href="http://localhost:16686" target="_blank" rel="noopener">http://localhost:16686</a>. The home page shows rich search functionality. There is a dropdown with all available services, then operations performed by the selected service can be also filtered.
<p><a href="/images/2021/10/Selenium-Observability-Jaeger-search.png"><img src="/images/2021/10/Selenium-Observability-Jaeger-search.png"></a></p>
<p>A trace can be opened from the search results. It shows all the actions for this trace that have been recorded.</p>
<p><a href="/images/2021/10/Selenium-Observability-Jaeger-trace.png"><img src="/images/2021/10/Selenium-Observability-Jaeger-trace.png"></a></p>
<h3>Grafana</h3>
Grafana is accessible at <a href="http://localhost:3001" target="_blank" rel="noopener">http://localhost:3001</a>. Different data sources can be accessed from the left-hand side menu, there is a small compass, the Explore menu. From the top, there is a dropdown with the available data sources.
<img src="/images/2021/10/Selenium-Observability-Grafana-datasources.png">
<h3>Grafana -> Loki</h3>
From Grafana select Loki as datasource. Search for <em><strong>{job="person-service"}</strong></em>, this shows all logs for the Spring Boot backend.
<p><a href="/images/2021/10/Selenium-Observability-Grafana-Loki.png"><img src="/images/2021/10/Selenium-Observability-Grafana-Loki.png"></a></p>
<h3>Grafana -> Jaeger</h3>
Jaeger data source can open a trace by its id. This data source can be used in conjunction with Loki. Search logs in Loki, then open a log, this exposes a Jaeger button.
<p><a href="/images/2021/10/Selenium-Observability-Grafana-Loki-Jaeger.png"><img src="/images/2021/10/Selenium-Observability-Grafana-Loki-Jaeger.png"></a></p>
<p>Jaeger data source can be opened directly from the dropdown, then type the TraceID.</p>
<p><a href="/images/2021/10/Selenium-Observability-Grafana-Jaeger.png"><img src="/images/2021/10/Selenium-Observability-Grafana-Jaeger.png"></a></p>
<h3>Grafana -> Prometheus</h3>
From Grafana select Prometheus as a data source. Search for <em><strong>{job="person-service"}</strong></em>, this shows all metrics for the Spring Boot backend.
<p><a href="/images/2021/10/Selenium-Observability-Grafana-Prometheus.png"><img src="/images/2021/10/Selenium-Observability-Grafana-Prometheus.png"></a></p>
<h3>Prometheus</h3>
Prometheus is accessible at <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a>. Search for <em><strong>{job="person-service"}</strong></em>, this shows all metrics for the Spring Boot backend.
<p><a href="/images/2021/10/Selenium-Observability-Prometheus.png"><img src="/images/2021/10/Selenium-Observability-Prometheus.png"></a></p>
<h2>Furter posts with details</h2>
This is an introductory post, more details, explanations, and code examples on actual implementation can be found in the following posts:
<ul>
 	<li><a href="/distributed-system-observability-instrument-spring-boot-application-with-opentelemetry/">Distributed system observability: Instrument Spring Boot application with OpenTelemetry</a></li>
 	<li><a href="/distributed-system-observability-instrument-react-application-with-opentelemetry/">Distributed system observability: Instrument React application with OpenTelemetry</a></li>
 	<li><a href="/distributed-system-observability-instrument-selenium-tests-with-opentelemetry/">Distributed system observability: Instrument Selenium tests with OpenTelemetry</a></li>
 	<li><a href="/distributed-system-observability-instrument-cypress-tests-with-opentelemetry/">Distributed system observability: Instrument Cypress tests with OpenTelemetry</a></li>
 	<li><a href="/distributed-system-observability-extract-and-visualize-metrics-from-opentelemetry-spans/">Distributed system observability: extract and visualize metrics from OpenTelemetry spans</a></li>
</ul>
<h2>Conclusion</h2>
Microservices architecture is used more often. Alongside its advantages, it comes with specific challenges. Observability is one of those challenges and is a very important topic in a distributed software system. In the current example, I have shown end-to-end observability achieved with popular open-source tools. The main objective of my experiments was to be able to trace Selenium test execution through all the systems involved in the distributed architecture.  </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>