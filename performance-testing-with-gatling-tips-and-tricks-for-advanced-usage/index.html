<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><script src="/scripts.js"></script><!-- Font preloads --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/performance-testing-with-gatling-tips-and-tricks-for-advanced-usage/"><!-- Primary Meta Tags --><title>Performance testing with Gatling – advanced usage</title><meta name="title" content="Performance testing with Gatling – advanced usage"><meta name="description" content="Code samples and explanation how to do advanced performance testing with Gatling, such as proper scenarios structure, checks, feeding test data, session maintenance, etc."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/performance-testing-with-gatling-tips-and-tricks-for-advanced-usage/"><meta property="og:title" content="Performance testing with Gatling – advanced usage"><meta property="og:description" content="Code samples and explanation how to do advanced performance testing with Gatling, such as proper scenarios structure, checks, feeding test data, session maintenance, etc."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/performance-testing-with-gatling-tips-and-tricks-for-advanced-usage/"><meta property="twitter:title" content="Performance testing with Gatling – advanced usage"><meta property="twitter:description" content="Code samples and explanation how to do advanced performance testing with Gatling, such as proper scenarios structure, checks, feeding test data, session maintenance, etc."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:calc(100% - 2em);margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}pre{margin:0;padding:12px}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}.tab{overflow:hidden;border:1px solid #ccc;background-color:#f1f1f1}.tab button{background-color:inherit;float:left;border:none;outline:none;cursor:pointer;padding:14px 16px;transition:.3s}.tab button:hover{background-color:#ddd}.tab button.active{background-color:#ccc}.tabcontent{display:none;border-top:none}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
article[data-astro-cid-bvzihdzo]{padding:24px;box-shadow:0 2px 3px #acabab;background:#fff;position:relative}.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}.tags[data-astro-cid-bvzihdzo]{display:flex;flex-wrap:wrap}.tags[data-astro-cid-bvzihdzo]>a[data-astro-cid-bvzihdzo]{margin-left:8px}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 class="post-title" data-astro-cid-bvzihdzo>Performance testing with Gatling – advanced usage</h1> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2015-11-12T00:00:00.000Z"> Nov 12, 2015 </time> </div> <hr data-astro-cid-bvzihdzo> </div>  <p>Current post is part of <a href="/performance-testing-with-gatling/">Performance testing with Gatling</a> series in which Gatling performance testing tool is explained in details.</p>
<p>Code samples are available in GitHub <a href="https://github.com/llatinov/sample-performance-with-gatling" target="_blank" rel="noopener">sample-performance-with-gatling</a> repository.</p>
<p>In previous post <a href="/performance-testing-with-gatling-integration-with-maven/">Performance testing with Gatling – integration with Maven</a> there is description how to setup Maven project. In <a href="/performance-testing-with-gatling-recorded-simulation-explanation/">Performance testing with Gatling – recorded simulation explanation</a> there is information what a simulation consists of. Simulations from this post will be refactored in current post and more advanced topics will be discussed how to make flexible automation testing with Gatling.</p>
<h2>What is included</h2>
Following topics are included in the current post:
<ul>
 	<li>Access external configuration data</li>
 	<li>Define single HTTP requests for better re-usability</li>
 	<li>Add checks for content on HTTP response</li>
 	<li>Check and extract data from HTTP response</li>
 	<li>More checks and extract List with values</li>
 	<li>Create HTTP POST request with the body from a template file</li>
 	<li>Manage session variables</li>
 	<li>Standard CSV feeder</li>
 	<li>Create custom feeder</li>
 	<li>Create unified scenarios</li>
 	<li>Conditional scenario execution</li>
 	<li>Only one HTTP protocol</li>
 	<li>Extract data from HTTP request and response</li>
 	<li>Advanced simulation setUp</li>
 	<li>Virtual users vs requests per second</li>
</ul>
<h2>Refactored code</h2>
Below are all classes that are created after they have been refactored. In order to separate things and make it easier to read ProductSimulation and PersonSimulation classes contain only the <em><strong>setUp()</strong></em> method. Request, scenarios and external configurations are being defined into Constants, Product and Person singleton objects.
<div class="tab"><button id="2391-Constants" class="tablinks active" onclick="openTab(this, &#x27;content-2391-Constants&#x27;, &#x27;2391&#x27;)">Constants</button>
<button id="2391-Product" class="tablinks" onclick="openTab(this, &#x27;content-2391-Product&#x27;, &#x27;2391&#x27;)">Product</button>
<button id="2391-ProductSimulation" class="tablinks" onclick="openTab(this, &#x27;content-2391-ProductSimulation&#x27;, &#x27;2391&#x27;)">ProductSimulation</button>
<button id="2391-Person" class="tablinks" onclick="openTab(this, &#x27;content-2391-Person&#x27;, &#x27;2391&#x27;)">Person</button>
<button id="2391-PersonSimulation" class="tablinks" onclick="openTab(this, &#x27;content-2391-PersonSimulation&#x27;, &#x27;2391&#x27;)">PersonSimulation</button></div>
<div id="content-2391-Constants" class="tabcontent" style="display: block">
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>object Constants {</span></span>
<span class="line"><span>    val numberOfUsers: Int = System.getProperty("numberOfUsers").toInt</span></span>
<span class="line"><span>    val duration: FiniteDuration = System.getProperty("durationMinutes").toInt.minutes</span></span>
<span class="line"><span>    val pause: FiniteDuration = System.getProperty("pauseBetweenRequestsMs").toInt.millisecond</span></span>
<span class="line"><span>    val responseTimeMs = 500</span></span>
<span class="line"><span>    val responseSuccessPercentage = 99</span></span>
<span class="line"><span>    private val url: String = System.getProperty("url")</span></span>
<span class="line"><span>    private val repeatTimes: Int = System.getProperty("numberOfRepetitions").toInt</span></span>
<span class="line"><span>    private val successStatus: Int = 200</span></span>
<span class="line"><span>    private val isDebug = System.getProperty("debug").toBoolean</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    val httpProtocol = http</span></span>
<span class="line"><span>        .baseURL(url)</span></span>
<span class="line"><span>        .check(status.is(successStatus))</span></span>
<span class="line"><span>        .extraInfoExtractor { extraInfo => List(getExtraInfo(extraInfo)) }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    def createScenario(name: String, feed: FeederBuilder[_], chains: ChainBuilder*): ScenarioBuilder = {</span></span>
<span class="line"><span>        if (Constants.repeatTimes > 0) {</span></span>
<span class="line"><span>            scenario(name).feed(feed).repeat(Constants.repeatTimes) {</span></span>
<span class="line"><span>                exec(chains).pause(Constants.pause)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            scenario(name).feed(feed).forever() {</span></span>
<span class="line"><span>                exec(chains).pause(Constants.pause)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private def getExtraInfo(extraInfo: ExtraInfo): String = {</span></span>
<span class="line"><span>        if (isDebug</span></span>
<span class="line"><span>            || extraInfo.response.statusCode.get != successStatus</span></span>
<span class="line"><span>            || extraInfo.status.eq(Status.apply("KO"))) {</span></span>
<span class="line"><span>            ",URL:" + extraInfo.request.getUrl +</span></span>
<span class="line"><span>                " Request: " + extraInfo.request.getStringData +</span></span>
<span class="line"><span>                " Response: " + extraInfo.response.body.string</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            ""</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
</div>
<div id="content-2391-Product" class="tabcontent">
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>object Product {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqGoToHome = exec(http("Open home page")</span></span>
<span class="line"><span>        .get("/products")</span></span>
<span class="line"><span>        .check(regex("Search: "))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqSearchProduct = exec(http("Search product")</span></span>
<span class="line"><span>        .get("/products?q=${search_term}&#x26;action=search-results")</span></span>
<span class="line"><span>        .check(regex("Your search for '${search_term}' gave ([\\d]{1,2}) results:").saveAs("numberOfProducts"))</span></span>
<span class="line"><span>        .check(regex("NotFound").optional.saveAs("not_found"))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqOpenProduct = exec(session => {</span></span>
<span class="line"><span>        var numberOfProducts = session("numberOfProducts").as[String].toInt</span></span>
<span class="line"><span>        var productId = Random.nextInt(numberOfProducts) + 1</span></span>
<span class="line"><span>        session.set("productId", productId)</span></span>
<span class="line"><span>    }).exec(http("Open Product")</span></span>
<span class="line"><span>        .get("/products?action=details&#x26;id=${productId}")</span></span>
<span class="line"><span>        .check(regex("This is 'Product ${productId} name' details page."))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    private val csvFeeder = csv("search_terms.csv").circular.random</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    val scnSearch = Constants.createScenario("Search", csvFeeder,</span></span>
<span class="line"><span>        reqGoToHome, reqSearchProduct, reqGoToHome)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    val scnSearchAndOpen = Constants.createScenario("Search and Open", csvFeeder,</span></span>
<span class="line"><span>        reqGoToHome, reqSearchProduct, reqOpenProduct, reqGoToHome)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
</div>
<div id="content-2391-ProductSimulation" class="tabcontent">
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class ProductSimulation extends Simulation {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    setUp(</span></span>
<span class="line"><span>        Product.scnSearch.inject(rampUsers(Constants.numberOfUsers) over 10.seconds),</span></span>
<span class="line"><span>        Product.scnSearchAndOpen.inject(atOnceUsers(Constants.numberOfUsers))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>        .protocols(Constants.httpProtocol.inferHtmlResources())</span></span>
<span class="line"><span>        .pauses(constantPauses)</span></span>
<span class="line"><span>        .maxDuration(Constants.duration)</span></span>
<span class="line"><span>        .assertions(</span></span>
<span class="line"><span>            global.responseTime.max.lessThan(Constants.responseTimeMs),</span></span>
<span class="line"><span>            global.successfulRequests.percent.greaterThan(Constants.responseSuccessPercentage)</span></span>
<span class="line"><span>        )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
</div>
<div id="content-2391-Person" class="tabcontent">
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>object Person {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val added = "Added"</span></span>
<span class="line"><span>    private val updated = "Updated"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqGetAll = exec(http("Get All Persons")</span></span>
<span class="line"><span>        .get("/person/all")</span></span>
<span class="line"><span>        .check(regex("\"firstName\":\"(.*?)\"").count.greaterThan(1).saveAs("count"))</span></span>
<span class="line"><span>        .check(regex("\\[").count.is(1))</span></span>
<span class="line"><span>        .check(regex("\"id\":([\\d]{1,6})").findAll.saveAs("person_ids"))</span></span>
<span class="line"><span>    ).exec(session => {</span></span>
<span class="line"><span>        val count = session("count").as[Int]</span></span>
<span class="line"><span>        val personIds = session("person_ids").as[List[Int]]</span></span>
<span class="line"><span>        val personId = personIds(Random.nextInt(count)).toString.toInt</span></span>
<span class="line"><span>        session.set("person_id", personId)</span></span>
<span class="line"><span>    }).exec(session => {</span></span>
<span class="line"><span>        println(session)</span></span>
<span class="line"><span>        session</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqGetPerson = exec(http("Get Person")</span></span>
<span class="line"><span>        .get("/person/get/${person_id}")</span></span>
<span class="line"><span>        .check(regex("\"firstName\":\"(.*?)\"").count.is(1))</span></span>
<span class="line"><span>        .check(regex("\\[").notExists)</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqSavePerson = exec(http("Save Person")</span></span>
<span class="line"><span>        .post("/person/save")</span></span>
<span class="line"><span>        .body(ElFileBody("person.json"))</span></span>
<span class="line"><span>        .header("Content-Type", "application/json")</span></span>
<span class="line"><span>        .check(regex("Person with id=([\\d]{1,6})").saveAs("person_id"))</span></span>
<span class="line"><span>        .check(regex("\\[").notExists)</span></span>
<span class="line"><span>        .check(regex("(" + added + "|" + updated + ") Person with id=").saveAs("action"))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqGetPersonAferSave = exec(http("Get Person After Save")</span></span>
<span class="line"><span>        .get("/person/get/${person_id}")</span></span>
<span class="line"><span>        .check(regex("\"id\":${person_id}"))</span></span>
<span class="line"><span>        .check(regex("\"firstName\":\"${first_name}\""))</span></span>
<span class="line"><span>        .check(regex("\"lastName\":\"${last_name}\""))</span></span>
<span class="line"><span>        .check(regex("\"email\":\"${email}\""))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val reqGetPersonAferUpdate = exec(http("Get Person After Update")</span></span>
<span class="line"><span>        .get("/person/get/${person_id}")</span></span>
<span class="line"><span>        .check(regex("\"id\":${person_id}"))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val uniqueIds: List[String] = Source</span></span>
<span class="line"><span>        .fromInputStream(getClass.getResourceAsStream("/account_ids.txt"))</span></span>
<span class="line"><span>        .getLines().toList</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private val feedSearchTerms = Iterator.continually(buildFeeder(uniqueIds))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private def buildFeeder(dataList: List[String]): Map[String, Any] = {</span></span>
<span class="line"><span>        Map(</span></span>
<span class="line"><span>            "id" -> (Random.nextInt(100) + 1),</span></span>
<span class="line"><span>            "first_name" -> Random.alphanumeric.take(5).mkString,</span></span>
<span class="line"><span>            "last_name" -> Random.alphanumeric.take(5).mkString,</span></span>
<span class="line"><span>            "email" -> Random.alphanumeric.take(5).mkString.concat("@na.na"),</span></span>
<span class="line"><span>            "unique_id" -> dataList(Random.nextInt(dataList.size))</span></span>
<span class="line"><span>        )</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    val scnGet = Constants.createScenario("Get all then one", feedSearchTerms,</span></span>
<span class="line"><span>        reqGetAll, reqGetPerson)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    val scnSaveAndGet = Constants.createScenario("Save and get", feedSearchTerms, reqSavePerson)</span></span>
<span class="line"><span>        .doIfEqualsOrElse("${action}", added) {</span></span>
<span class="line"><span>            reqGetPersonAferSave</span></span>
<span class="line"><span>        } {</span></span>
<span class="line"><span>            reqGetPersonAferUpdate</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
</div>
<div id="content-2391-PersonSimulation" class="tabcontent">
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class PersonSimulation extends Simulation {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    setUp(</span></span>
<span class="line"><span>        Person.scnGet.inject(atOnceUsers(Constants.numberOfUsers)),</span></span>
<span class="line"><span>        Person.scnSaveAndGet.inject(atOnceUsers(Constants.numberOfUsers))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>        .protocols(Constants.httpProtocol)</span></span>
<span class="line"><span>        .pauses(constantPauses)</span></span>
<span class="line"><span>        .maxDuration(Constants.duration)</span></span>
<span class="line"><span>        .assertions(</span></span>
<span class="line"><span>            global.responseTime.max.lessThan(Constants.responseTimeMs),</span></span>
<span class="line"><span>            global.successfulRequests.percent.greaterThan(Constants.responseSuccessPercentage)</span></span>
<span class="line"><span>        )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
</div>
<h2>Access external configuration data</h2>
In order to have flexibility it is mandatory to be able to sent different configurations parameters from command line when invoking the scenario. With Gatling Maven plugin it is done with  configurations. See more in <a href="/performance-testing-with-gatling-integration-with-maven/">Performance testing with Gatling – integration with Maven</a> post.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>val numberOfUsers: Int = System.getProperty("numberOfUsers").toInt</span></span>
<span class="line"><span>val duration: FiniteDuration = System.getProperty("durationMinutes").toInt.minutes</span></span>
<span class="line"><span>private val url: String = System.getProperty("url")</span></span>
<span class="line"><span>private val repeatTimes: Int = System.getProperty("numberOfRepetitions").toInt</span></span>
<span class="line"><span>private val isDebug = System.getProperty("debug").toBoolean</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Define single HTTP requests for better re-usability</h2>
It is a good idea to define each HTTP request as a separate object. This gives the flexibility to reuse one and the same requests in different scenarios. Below is shown how to create HTTP GET request with <em><strong>http().get()</strong></em>.
<h2>Add checks for content on HTTP response</h2>
On HTTP request creation there is a possibility to add checks that certain string or regular expression pattern exists in response. The code below created HTTP Request and add check that <em><strong>"Search: "</strong></em> text exists in response. This is done with <em><strong>regex()</strong></em> method by passing just a string to it.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val reqGoToHome = exec(http("Open home page")</span></span>
<span class="line"><span>    .get("/products")</span></span>
<span class="line"><span>    .check(regex("Search: "))</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Check and extract data from HTTP response</h2>
It is possible along with the check to extract data into a variable that is being saved to the session. This is done with <em><strong>saveAs()</strong></em> method. In some cases value we are searching for, might not be in the response. We can use <em><strong>optional</strong></em> method to specify that value is saved in session only if existing. If it is not existing it won't be captured and this will not break the execution. As shown below session variables can be also used in the checks. Session variable is accessed with <em><strong>${}</strong></em>,  such as <em><strong>${search_term}</strong></em>.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val reqSearchProduct = exec(http("Search product")</span></span>
<span class="line"><span>    .get("/products?q=${search_term}&#x26;action=search-results")</span></span>
<span class="line"><span>    .check(regex("Your search for '${search_term}' gave ([\\d]{1,2}) results:")</span></span>
<span class="line"><span>        .saveAs("numberOfProducts"))</span></span>
<span class="line"><span>    .check(regex("NotFound").optional.saveAs("not_found"))</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span></code></pre>
<h2>More checks and extract List with values</h2>
There are many types of checks. In code below <em><strong>count.greaterThan(1)</strong></em> and <em><strong>count.is(1)</strong></em> are used. It is possible to search for multiple occurrences of given regular expression with <em><strong>findAll</strong></em>. In such case <em><strong>saveAs()</strong></em> saves the results to a "person_ids" List object in session. More information about checks can be found in <a href="https://gatling.io/docs/current/http/http_check/" target="_blank" rel="noopener">Gatling Checks page</a>.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val reqGetAll = exec(http("Get All Persons")</span></span>
<span class="line"><span>    .get("/person/all")</span></span>
<span class="line"><span>    .check(regex("\"firstName\":\"(.*?)\"").count.greaterThan(1).saveAs("count"))</span></span>
<span class="line"><span>    .check(regex("\\[").count.is(1))</span></span>
<span class="line"><span>    .check(regex("\"id\":([\\d]{1,6})").findAll.saveAs("person_ids"))</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Create HTTP POST request with the body from a template file</h2>
If you need to post data to server HTTP POST request is to be used. The request is created with <em><strong>http().post()</strong></em> method. Headers can be added to the request with <em><strong>header()</strong></em> or <em><strong>headers()</strong></em> methods. In the current example, without Content-Type=application/json header REST service will throw an error for unrecognized content. Data that will be sent is added in <em><strong>body()</strong></em> method. It accepts Body object. You can generate body from a file (<em><strong>RawFileBody</strong></em> method) or string (<em><strong>StringBody</strong></em> method).
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val reqSavePerson = exec(http("Save Person")</span></span>
<span class="line"><span>    .post("/person/save")</span></span>
<span class="line"><span>    .body(ElFileBody("person.json"))</span></span>
<span class="line"><span>    .header("Content-Type", "application/json")</span></span>
<span class="line"><span>    .check(regex("Person with id=([\\d]{1,6})").saveAs("person_id"))</span></span>
<span class="line"><span>    .check(regex("\\[").notExists)</span></span>
<span class="line"><span>    .check(regex("(" + added + "|" + updated + ") Person with id=")</span></span>
<span class="line"><span>        .saveAs("action"))</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span></code></pre>
<p>In current case body is generated from file, which have variables that can be later on found in session. This is done with <em><strong>ElFileBody</strong></em> (ELFileBody in 2.0.0) method and actual replace with value is done by Gatling EL (expression language). More about what can you do with EL can be found on <a href="https://gatling.io/docs/current/session/expression_el/" target="_blank" rel="noopener">Gatling EL page</a>. EL body file is shown below, where variables ${id}, ${first_name}, ${last_name} ${email} are searched in session and replaced if found. If not found error is shown on scenario execution output.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>{</span></span>
<span class="line"><span>    "id": "${id}",</span></span>
<span class="line"><span>    "firstName": "${first_name}",</span></span>
<span class="line"><span>    "lastName": "${last_name}",</span></span>
<span class="line"><span>    "email": "${email}"</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Manage session variables</h2>
Each virtual user has its own session. The scenario can store or read data from the session. Data is saved in session with key/value pairs, where the key is the variable name. Variables are stored in session in three ways: using <em><strong>feeders</strong></em> (this is explained later in the current post), using <em><strong>saveAs()</strong></em> method and <em><strong>session</strong></em> API. More details on session API can be found in <a href="https://gatling.io/docs/current/session/session_api/" target="_blank" rel="noopener">Gatling Session API page</a>.
<p>Manipulating session through API is kind of tricky. Gatling documentation is vague about it. Below is shown a code where session variable is extracted first as String and then converted to Int with: <em><strong>var numberOfProducts = session(“numberOfProducts”).as[String].toInt</strong></em>. On next step some manipulation is done with this variable, in current case, a random product id from 1 to “numberOfProducts” to is picked. At last a new variable is saved in session with <em><strong>session.set(“productId”, productId)</strong></em>. It is important that this is the last line of session manipulation code block done in first <em><strong>exec()</strong></em>. This is the return statement of the code block. In other words, new Session object with saved “productId” in it is returned. If on the last line is just “session” as stated in the docs, then old, an unmodified session object is returned without variable being added.</p>
<p>Sessions as most of the objects in Gatling and in Scala are immutable. This is designed for thread safety. So adding a variable to session actually creates a new object. This is why newly added session variable cannot be used in the same <em><strong>exec()</strong></em> block, but have to be used on next one, as in same block variable is yet not accessible. See code below in the second <em><strong>exec()</strong></em> “productId” is already available and can be used in <em><strong>get()</strong></em>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val reqOpenProduct = exec(session => {</span></span>
<span class="line"><span>    var numberOfProducts = session("numberOfProducts").as[String].toInt</span></span>
<span class="line"><span>    var productId = Random.nextInt(numberOfProducts) + 1</span></span>
<span class="line"><span>    session.set("productId", productId)</span></span>
<span class="line"><span>}).exec(http("Open Product")</span></span>
<span class="line"><span>    .get("/products?action=details&#x26;id=${productId}")</span></span>
<span class="line"><span>    .check(regex("This is 'Product ${productId} name' details page."))</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span></code></pre>
<p>Same logic being explained above is implemented in next code fragment. The below example shows usage of session variable saved in previous <em><strong>exec()</strong></em> fragment. Count of persons and List with ids are being saved by <em><strong>saveAs()</strong></em> method. The list is extracted from the session and random index of it has been accessed, so random person is being selected. This is again saved into session as “person_id”. In third <em><strong>exec()</strong></em> statement “session” object is just printed to output for debugging purposes.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val reqGetAll = exec(http("Get All Persons")</span></span>
<span class="line"><span>    .get("/person/all")</span></span>
<span class="line"><span>    .check(regex("\"firstName\":\"(.*?)\"").count.greaterThan(1).saveAs("count"))</span></span>
<span class="line"><span>    .check(regex("\\[").count.is(1))</span></span>
<span class="line"><span>    .check(regex("\"id\":([\\d]{1,6})").findAll.saveAs("person_ids"))</span></span>
<span class="line"><span>).exec(session => {</span></span>
<span class="line"><span>    val count = session("count").as[Int]</span></span>
<span class="line"><span>    val personIds = session("person_ids").as[List[Int]]</span></span>
<span class="line"><span>    val personId = personIds(Random.nextInt(count)).toString.toInt</span></span>
<span class="line"><span>    session.set("person_id", personId)</span></span>
<span class="line"><span>}).exec(session => {</span></span>
<span class="line"><span>    println(session)</span></span>
<span class="line"><span>    session</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Standard CSV feeder</h2>
A feeder is a way to generate unique data for each virtual user. This how tests are made real. Below is a way to read data from CSV file. The first line of the CSV file is the header which is saved to the session as a variable name. In the current example, CSV has only one column, but it is possible to have CSV file with several columns. <em><strong>circular</strong></em> means that if file end is reached feeder will start from the beginning. <em><strong>random</strong></em> means elements are taken in random order. More about feeders can be found in <a href="https://gatling.io/docs/current/session/feeder/" target="_blank" rel="noopener">Gatling Feeders page</a>.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val csvFeeder = csv("search_terms.csv").circular.random</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Create custom feeder</h2>
Feeder actually is Iterator[Map[String, T]], so you can do your own feeders. Below is shown code where some unique ids are read from file and converted to List[String] with <em><strong>Source .fromInputStream(getClass.getResourceAsStream("/account_ids.txt")) .getLines().toList</strong></em>. This list is used in <em><strong>buildFeeder()</strong></em> method to access random element from it. Finally <em><strong>Iterator.continually(buildFeeder(uniqueIds))</strong></em> creates infinite length iterator.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val uniqueIds: List[String] = Source</span></span>
<span class="line"><span>    .fromInputStream(getClass.getResourceAsStream("/account_ids.txt"))</span></span>
<span class="line"><span>    .getLines().toList</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private val feedSearchTerms = Iterator.continually(buildFeeder(uniqueIds))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private def buildFeeder(dataList: List[String]): Map[String, Any] = {</span></span>
<span class="line"><span>    Map(</span></span>
<span class="line"><span>        "id" -> (Random.nextInt(100) + 1),</span></span>
<span class="line"><span>        "first_name" -> Random.alphanumeric.take(5).mkString,</span></span>
<span class="line"><span>        "last_name" -> Random.alphanumeric.take(5).mkString,</span></span>
<span class="line"><span>        "email" -> Random.alphanumeric.take(5).mkString.concat("@na.na"),</span></span>
<span class="line"><span>        "unique_id" -> dataList(Random.nextInt(dataList.size))</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>The current business case doesn’t make much sense to have a custom feeder with values from a file, just <em><strong>Map()</strong></em> generator is enough. But let us imagine a case where you search for a hotel by unique id and some date in the future. Hard coding date in CSV file is not a wise solution, you will want to be always in the future. Also making different combinations from hotelId, start and end dates is not possible to be maintained in a file. The best solution is to have a file with hotel ids and dates to be dynamically generated as shown in <em><strong>buildFeeder()</strong></em> method.</p>
<h2>Create unified scenarios</h2>
The scenario is created from HTTP requests. This is why it is good to have each HTTP request as a separate object so you can reuse them in different scenarios. In order to unify scenario creation, there is a special method. It takes scenario name, feeder and list of requests and returns a scenario object. Method checks if the scenario is supposed to be repeated several times and uses <em><strong>repeat()</strong></em> method. Else scenarios are repeated <em><strong>forever()</strong></em>. In both cases, there is constant pause time introduced between requests with <em><strong>pause()</strong></em>.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>def createScenario(name: String, </span></span>
<span class="line"><span>                    feed: FeederBuilder[_],</span></span>
<span class="line"><span>                    chains: ChainBuilder*): ScenarioBuilder = {</span></span>
<span class="line"><span>    if (Constants.repeatTimes > 0) {</span></span>
<span class="line"><span>        scenario(name).feed(feed).repeat(Constants.repeatTimes) {</span></span>
<span class="line"><span>            exec(chains).pause(Constants.pause)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        scenario(name).feed(feed).forever() {</span></span>
<span class="line"><span>            exec(chains).pause(Constants.pause)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>With this approach, a method can be reused from many places avoiding duplication of code.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>val scnSearch = Constants.createScenario("Search", csvFeeder,</span></span>
<span class="line"><span>        reqGoToHome, reqSearchProduct, reqGoToHome)</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Conditional scenario execution</h2>
It is possible one scenario to have different execution paths based on a condition. This condition is generally a value of a session variable. Branching is done with <em><strong>doIf</strong></em>, <em><strong>doIfElse</strong></em>, <em><strong>doIfEqualsOrElse</strong></em>, etc methods. In the current example, if this is Save request then additional <em><strong>reqGetPersonAferSave</strong></em> HTTP request is executed. Else additional <em><strong>reqGetPersonAferUpdate</strong></em> HTTP request is executed. In the end, there is only one scenario <em><strong>scnSaveAndGet</strong></em> but it can have different execution paths based on "action" session variable.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>val scnSaveAndGet = Constants</span></span>
<span class="line"><span>    .createScenario("Save and get", feedSearchTerms, reqSavePerson)</span></span>
<span class="line"><span>    .doIfEqualsOrElse("${action}", added) {</span></span>
<span class="line"><span>        reqGetPersonAferSave</span></span>
<span class="line"><span>    } {</span></span>
<span class="line"><span>        reqGetPersonAferUpdate</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Only one HTTP protocol</h2>
In general case, several performance testing simulations can be done for one and the same application. During simulation setUp an HTTP protocol object is needed. Since the application is the same HTTP protocol can be one and the same object, so it is possible to define it and reuse it. If changes are needed new HTTP protocol object can be defined or a copy of current one can be created and modified.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>val httpProtocol = http</span></span>
<span class="line"><span>    .baseURL(url)</span></span>
<span class="line"><span>    .check(status.is(successStatus))</span></span>
<span class="line"><span>    .extraInfoExtractor { extraInfo => List(getExtraInfo(extraInfo)) }</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Extract data from HTTP request and response</h2>
In order to ease debugging of failures or debugging at all, it is possible to extract information from HTTP request and response. Extraction is configured on HTTP protocol level with <em><strong>extraInfoExtractor { extraInfo => List(getExtraInfo(extraInfo)) }</strong></em> as shown above. In order to simplify code processing of extra info object is done in a separate method. If debug is enabled or response code is not 200 or Gatling status is KO then request URL, request data and response body are dumped into <em><strong>simulation.log</strong></em> file that resides in results folder. Note that response body is extracted only if there is check on it, otherwise, there is <em><strong>NoResponseBody</strong></em> in the output. This is done to improve performance.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private def getExtraInfo(extraInfo: ExtraInfo): String = {</span></span>
<span class="line"><span>    if (isDebug</span></span>
<span class="line"><span>        || extraInfo.response.statusCode.get != successStatus</span></span>
<span class="line"><span>        || extraInfo.status.eq(Status.apply("KO"))) {</span></span>
<span class="line"><span>        ",URL:" + extraInfo.request.getUrl +</span></span>
<span class="line"><span>            " Request: " + extraInfo.request.getStringData +</span></span>
<span class="line"><span>            " Response: " + extraInfo.response.body.string</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        ""</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Advanced simulation setUp</h2>
It is a good idea to keep simulation class clean by defining all objects in external classes or singleton objects. Simulation is mandatory to have <em><strong>setUp()</strong></em> method. It receives a comma-separated list of scenarios. In order scenario to be valid, it should have users injected with <em><strong>inject()</strong></em> method. There are different strategies to inject users. The protocol should also be defined per scenario setup. In this particular example default protocol is used with the change to fetch all HTTP resources on a page (JS, CSS, images, etc.) with <em><strong>inferHtmlResources()</strong></em>. Since objects are immutable this creates a copy of default HTTP protocol and does not modify the original one. Assertions is a way to verify certain performance KPI it is defined with <em><strong>assertions()</strong></em> method. In this example, we should have a response time less than 500ms and more than 99% of requests should be successful.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>private val rampUpTime: FiniteDuration = 10.seconds</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setUp(</span></span>
<span class="line"><span>    Product.scnSearch.inject(rampUsers(Constants.numberOfUsers) over rampUpTime),</span></span>
<span class="line"><span>    Product.scnSearchAndOpen.inject(atOnceUsers(Constants.numberOfUsers))</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>    .protocols(Constants.httpProtocol.inferHtmlResources())</span></span>
<span class="line"><span>    .pauses(constantPauses)</span></span>
<span class="line"><span>    .maxDuration(Constants.duration)</span></span>
<span class="line"><span>    .assertions(</span></span>
<span class="line"><span>        global.responseTime.max.lessThan(Constants.responseTimeMs),</span></span>
<span class="line"><span>        global.successfulRequests.percent</span></span>
<span class="line"><span>            .greaterThan(Constants.responseSuccessPercentage)</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>    .throttle(reachRps(100) in rampUpTime, holdFor(Constants.duration))</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Cookies management</h2>
Cookie support is enabled by default and then Gatling handles Cookies transparently, just like a browser would. It is possible to add or delete cookies during the simulation run. See more details how this is done in <a href="https://gatling.io/docs/current/http/http_helpers/" target="_blank" rel="noopener">Gatling Cookie management page</a>.
<h2>Virtual users vs requests per second</h2>
Since users are vague metric, but requests per second is metric that most server monitoring tools support it is possible to use this approach. Gatling supports so-called throttling: <em><strong>throttle(reachRps(100) in 10.seconds, holdFor(5.minutes))</strong></em>. It is important to put <em><strong>holdFor()</strong></em> method, otherwise, Gatling goes to unlimited requests per second and can crash the server. More details on simulation setup can be found on <a href="https://gatling.io/docs/current/general/simulation_setup/" target="_blank" rel="noopener">Gatling Simulation setup page</a>.
<h2>Conclusion</h2>
Keeping Gatling code maintainable and reusable is a good practice to create complex performance scenarios. Gatling API provides a wide range of functionalities to support this task. In the current post, I have shown cases and solution to them which I have encountered in real life projects.  <hr data-astro-cid-bvzihdzo>  <h2 data-astro-cid-bvzihdzo>Related Posts</h2> <ul data-astro-cid-bvzihdzo> <li data-astro-cid-bvzihdzo> <a href="/performance-testing-with-gatling/" data-astro-cid-bvzihdzo>Performance testing with Gatling</a> </li><li data-astro-cid-bvzihdzo> <a href="/performance-testing-with-gatling-integration-with-maven/" data-astro-cid-bvzihdzo>Performance testing with Gatling - integration with Maven</a> </li> </ul>  <div class="tags" data-astro-cid-bvzihdzo> <div data-astro-cid-bvzihdzo>Tags:</div> <a href="/tags/gatling" data-astro-cid-bvzihdzo>Gatling</a><a href="/tags/non-functional" data-astro-cid-bvzihdzo>Non-functional</a><a href="/tags/performance" data-astro-cid-bvzihdzo>Performance</a><a href="/tags/scala" data-astro-cid-bvzihdzo>Scala</a><a href="/tags/tutorials" data-astro-cid-bvzihdzo>Tutorials</a> </div> </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>