<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><script src="/scripts.js"></script><!-- Font preloads --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/what-is-the-test-mushroom-and-how-to-improve-your-testing/"><!-- Primary Meta Tags --><title>What is The Test Mushroom and how to improve your testing</title><meta name="title" content="What is The Test Mushroom and how to improve your testing"><meta name="description" content="In contrast to Test Pyramid, Test Mushroom shows a test portfolio which is restricted to costly and slow UI tests only. In the current post, I will describe approaches to act on your Test Mushroom hence improve your testing."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/what-is-the-test-mushroom-and-how-to-improve-your-testing/"><meta property="og:title" content="What is The Test Mushroom and how to improve your testing"><meta property="og:description" content="In contrast to Test Pyramid, Test Mushroom shows a test portfolio which is restricted to costly and slow UI tests only. In the current post, I will describe approaches to act on your Test Mushroom hence improve your testing."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/what-is-the-test-mushroom-and-how-to-improve-your-testing/"><meta property="twitter:title" content="What is The Test Mushroom and how to improve your testing"><meta property="twitter:description" content="In contrast to Test Pyramid, Test Mushroom shows a test portfolio which is restricted to costly and slow UI tests only. In the current post, I will describe approaches to act on your Test Mushroom hence improve your testing."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:100%;margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}pre{margin:0;padding:12px}.card{padding:16px;margin:10px;box-shadow:0 2px 3px #acabab;background:#fff;border-radius:24px;color:inherit}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}.tab{overflow:hidden;border:1px solid #ccc;background-color:#f1f1f1}.tab button{background-color:inherit;float:left;border:none;outline:none;cursor:pointer;padding:14px 16px;transition:.3s}.tab button:hover{background-color:#ddd}.tab button.active{background-color:#ccc}.tabcontent{display:none;border-top:none}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}.tags[data-astro-cid-bvzihdzo]{display:flex;flex-wrap:wrap}.tags[data-astro-cid-bvzihdzo]>a[data-astro-cid-bvzihdzo]{margin-left:8px}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article class="card" data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 class="post-title" data-astro-cid-bvzihdzo>What is The Test Mushroom and how to improve your testing</h1> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2018-05-14T00:00:00.000Z"> May 14, 2018 </time> </div> <hr data-astro-cid-bvzihdzo> </div>  <h2>Test Pyramid</h2>
<img src="/images/2018/05/TestPyramid.png">
<p><span>Test pyramid illustrates how your test portfolio is good to look like. The important thing about the test pyramid is the higher in the test pyramid the more brittle and expensive to maintain the tests are. In the bottom of the pyramid are the <em><strong>unit</strong></em> tests. They are fast and test most of the functionality in your code. By <em><strong>integration</strong></em> tests is meant the following thing. Defacto the standard now for web applications is to use some JavaScript UI framework that manipulates data from different APIs. With integration testing, we want to be in control of this data. We want for e.g. to test how web application behaves when API returns an error. By stubbing the data web application works with it is possible to fully test the web application. <em><strong>UI/E2E</strong></em> tests are the ones executed against deployed, configured, integrated and working web application. They are slow and flaky, thus they should be limited in number. In other versions of test pyramid, there is a layer called <em><strong>service tests</strong></em>, which is below UI and above integration. Those are API tests performed against deployed and working backend. I will not go into details about them, because API tests are by definition very stable.</span></p>
<h2>Test Mushroom</h2>
<img src="/images/2018/05/TestMushroom.png">
<p>I came up with this term when giving a presentation for Cypress, you can see more in <a href="/cypress-vs-selenium-end-era/">Cypress vs. Selenium, is this the end of an era?</a> post. This term was meant to be a funny and ironic description of a test portfolio that makes testing big pain because <span>the quality of releases totally depends on <em><strong>UI</strong></em> tests. The mushroom leg represents <em><strong>unit</strong></em> and <em><strong>integration</strong></em> tests. It is shown with a dotted line as such test are totally missing. UI tests are slow and flaky, every release sign off takes a lot of time for debugging failed tests. Every release has a high risk of failure. T</span>his is very similar to the <em><strong>Test Ice-Cream Cone</strong></em>, with the difference that in case of <em><strong>Test Mushroom</strong></em> integration and unit tests are missing.</p>
<h2>Need for an action</h2>
Whether it is a test mushroom or test ice-cream cone, it is not important. The important is both represent a situation where product quality depends on brittle and flaky UI tests. This should be acted upon in order to reduce the release related risk. In the current post, I will suggest some approaches how to act in this situation and put yourself in a better position. Below is a high-level list of what you can do. Each item from the list will be described with greater details later in the current post.
<ul>
 	<li>Refactor and optimize UI tests</li>
 	<li>Provision dedicated test environment</li>
 	<li>Increase integration testing</li>
 	<li>Unit testing and shift left</li>
</ul>
<h2>Refactor and optimize UI tests</h2>
The first thing you can do is act on UI tests because you have full control over them. Go over current tests and do a full review on them. In most of the cases, there are duplicated tests. With time being people add new tests and they keep piling up. This happens because it is easier to add new test rather than inspecting already existing ones and fit your tests scenario inside. You need to optimize your current tests. It might not happen immediately, it can be done a single step at a time, but you should do it. If several test scenarios can be fit into one automated test, then definitely do it. There are theories that say one test should test one thing only. I totally agree with this statement, but it is only relevant for the unit tests. For UI/E2E/functional tests this statement is more likely a good wish. UI tests are expensive, so we should optimize them as much as possible.
<h3>Classification tree test method</h3>
You should look for more details for <a href="https://en.wikipedia.org/wiki/Classification_Tree_Method" target="_blank" rel="noopener noreferrer">classification tree method</a>. I will give a short example. Imagine you have an e-commerce website. In this site, there are 3 main types of products: single product, a product with variations, e.g. several colors, and product set. This site offers 3 different deliveries, one international and two domestic shipping methods. Users can pay with Paypal, Visa, MasterCard, and Amex. With classification tree method you will have 3 different classifications: product type, shipping method, and payment method. The full test cases that can be done is a cartesian product from values of all classifications. In current example this 3 (product types) x 3 (shipping methods) x 4 (payment methods) = 36 full combinations. Minimum test cases that can be done though are 4, or the classification with most values. The 4 test cases we definitely must do are:
<ul>
 	<li>Single product with international delivery and PayPal</li>
 	<li>Blue variation product with domestic delivery #1 and Visa</li>
 	<li>Red variation product with international delivery and MasterCard</li>
 	<li>A product set with domestic delivery #2 and Amex</li>
</ul>
<h3>Soft assertions</h3>
Once you optimize tests number and workflow you would like to make as many assertions as possible while you are on each page. In this regards, so-called soft assertions can be used. Opposing to traditional unit testing asserts, where the test fails immediately when an error is found, a soft assertion is one that does not fail in case of a not critical problem. This provides the ability to execute all the steps in the test and then investigate the issues. <a href="/soft-assertions-not-fail-junit-test/">Soft assertions that do not fail JUnit test</a> and <a href="/soft-assertions-c-unit-testing-frameworks-mstest-nunit-xunit-net/">Soft assertions for C# unit testing frameworks (MSTest, NUnit, xUnit.net)</a> posts can give you more details how to do it in Java and C#.
<h3>Rename test methods</h3>
It is good to rename your test methods to be as much descriptive as possible. It does not matter that method name will contradict with best practices for method naming because those are test methods. If your tests fail you can identify them very easily just by the name of the failed method.
<h3>Use smarter waits</h3>
I get really upset when I see in test something like <em><strong>Thread.Sleep(5000)</strong></em>. You should never ever use such waits. Not only they are slowing you tests down but they will make the test fail if for some reason website is taking <em><strong>6 seconds</strong></em> to render. Selenium offers explicit and implicit waits, you should be very familiar with them. Another approach is to use even smarter mechanisms. Like, check for jQuery opened connections or for the existence of some kind of loader on your web application. See <a href="/efficient-waiting-for-ajax-call-data-loading-with-selenium-webdriver/">Efficient waiting for Ajax call data loading with Selenium WebDriver</a> post for more details. Cypress, on the other hand, eliminates waiting at all, as it knows what happens in the browser and it gives you the element once it is shown.
<h3>Retry failed tests</h3>
If you do not already have, you definitely need a retry mechanism for your tests. In <a href="/retry-junit-failed-tests-immediatelly/">Retry JUnit failed tests immediately</a> post, I have described how this can be done for JUnit. In <a href="/testing-with-cypress-lessons-learned-in-a-complete-framework/">Testing with Cypress – lessons learned in a complete framework</a> post, I have described a way to retry failed tests.
<h3>Screenshot failed tests</h3>
In order to ease yourself debugging a screenshot is a must. Along with the screenshot, it is good to have page source and URL at which screenshot was captured.
<h2>Provision dedicated test environment</h2>
In case of a shared environment, it is always possible that someone is doing something while tests are running. It is very good if you can provision a dedicated test environment. You should at any point know which version of the software under test are deployed on it and no one should mess with the test environment. If you have an application that consists of a database and API that is consumed by a UI then you can relatively easy use Docker to get a running test environment. If you are testing some application which is part of a big microservice ecosystem, then it might not be that easy, because you have to have dedicated environment for each dependent microservice, and they can be a big number.
<h3>Control test data in the database</h3>
Ideally, you want to have full control over the data in the database. In this way you can very easily assert and check for data you know is there. Ono option is in case of an application with own database, it is very easy to have a Docker image with already prefilled test data in the database and use it. If not using preloaded data you can still seed the data with API calls prior to the tests.
<p>Dedicated test environment not only can make your tests more stable but can make them faster. Check <a href="https://emanuilslavov.com/need-for-speed-my-slides-from-agile-testing-days/" target="_blank" rel="noopener noreferrer">Emanuil Slavov’s Need for Speed presentation</a>, this talk is also available in <a href="https://www.youtube.com/watch?v=khSsjjg2eSQ" target="_blank" rel="noopener noreferrer">GTAC 2016 video</a>.</p>
<h2>Increase integration testing</h2>
So far you have optimized your UI tests. If you are satisfied with the results, then maybe no further steps are needed. Remember, we do certain things, not because everybody is doing it but because we need it. If you need more improvements then you can look into integration testing. With term integration testing I mean testing of your application or parts of it by stubbing or mocking external dependencies. Below are several suggestions how you can do this.
<h3>JavaScript rich web application</h3>
In case of a web application built with some JavaScript framework that consumes the data from external APIs and renders the UI based on the data then there are two approaches to do integration testing. One is to use Cypress, which has a very good feature set for decent integration testing in the browser. See <a href="/cypress-vs-selenium-end-era/">Cypress vs. Selenium, is this the end of an era?</a> post for more details. The other approach is to use external stubs and have your application under test configured to work with the stubs. You can even make your testing framework to start and manage the stubs. See <em><strong>WireMock</strong></em> and <em><strong>Own stubbing</strong></em> sections below.
<h3>API backend application</h3>
In case of backend application that exposes different APIs for external consumption then the approach for integration testing is to stub or mock its dependencies. Dependency can be a database or external API that is being called. Database stubbing depends on the type of application and database used. For .NET application using Entity Framework, it is possible to mock the framework itself. The good thing about .NET is that it provides so-called <em><strong>TestHost</strong></em>, which can run your application in memory and you can also mock some of your dependencies if you have built your application properly to use inversion of control container. See more in <a href="/net-core-integration-testing-mock-dependencies/">.NET Core integration testing and mock dependencies</a> post. When speaking with colleagues they say Spring framework for Java provides similar functionalities, but I do not have experience with it. In terms of database, it depends which database has been used. If it is MS SQL Server, then one option, besides totally mocking the DB calls, is to use SQL Express (localdb). It runs on Windows machine and is extremely fast. It is very easy to create a new database and then run your application with this database. For MySQL I've seen in presentations that it is possible to run it in memory but I haven't tried this. Mocking dependencies to external applications again can be done either with <em><strong>WireMock</strong></em> or with <em><strong>Own Stubbing</strong></em>. You can have an instance of your application installed in separate integration environment and configured to use stubs instead of real dependency APIs.
<h3>Server-side HTML rendering</h3>
Integration testing of web application which HTML is rendered on the server and just given to the browser is very similar to the previous section <em><strong>API backend application</strong></em>.
<h3>WireMock</h3>
<a href="http://wiremock.org/" target="_blank" rel="noopener noreferrer">WireMock</a><span> is a simulator for HTTP-based APIs. Some might consider it a service virtualization tool or a mock server. It enables you to stay productive when an API you depend on doesn’t exist or isn’t complete. It supports testing of edge cases and failure modes that the real API won’t reliably produce. And because it’s fast it can reduce your build time from hours down to minutes. I have shown how WireMock can be used in unit tests in </span><a href="/mock-stub-rest-api-wiremock-better-unit-testing/">Mock/Stub REST API with WireMock for better unit testing</a> post. It can be run as standalone Java application with different endpoints and responses configured. So you can make WireMock reply differently based on the request it receives. This can be synchronized with your tests and you can automate whatever scenarios you need. Challenge with this approach is to keep both tests and mocked data in sync.
<h3>Own stubbing</h3>
It is possible to build own stub and configure it with whatever scenarios you want. I have described how you can do this in Java, .NET and Node.js in following posts: <a href="/build-a-rest-stub-server-with-dropwizard/">Build a RESTful stub server with Dropwizard</a>, <a href="/build-a-rest-api-with-net-core-2-and-run-it-on-docker-linux-container/">Build a REST API with .NET Core 2 and run it on Docker Linux container</a>, and <a href="/build-rest-api-express-node-js-run-docker/">Build a REST API with Express on Node.js and run it on Docker</a>.
<h2>Unit testing and shift left</h2>
The base of test pyramid are the unit tests. I have many posts on my blog regarding unit testing so in the current post, I will not go into further details about them because this more in development expertise. From my experience, if you have good UI and integration tests, you can have a very good level of quality without unit testing. I will refer to <a href="https://emanuilslavov.com/integration-tests-are-awesome/" target="_blank" rel="noopener noreferrer">Emanuil Slavov's Integration Tests Are Awesome</a> post. He had spent a significant amount of time investigating bugs in their bug tracking system and linking them to a layer of testing. He had discovered that only 13% of the bugs they could have caught with unit testing. Another 57% of the bugs they would have caught with API and UI testing. Latter 30% they have discovered could not have been caught with any kind of testing. I guess integration testing can cover some of the 30% uncatchable bugs because you can stub and mock the dependencies and this gives you better flexibility. So this is a good proof that you can go without unit testing. The real benefit of the unit testing though is the <em><strong>Shift Left</strong></em> paradigm. It involves developers in the process of building quality in the application. If developers should write unit tests to their code they catch and fix bugs almost immediately. With the time being developers learn to imply quality in their code. Your UI and integration tests will also catch most of the bugs. The more important is that the process of reporting and fixing bugs caught during UI and integration testing includes more time and effort. This is why writing unit tests are mandatory for any organization that wants to deliver quality products.
<h2>Conclusion</h2>
This post had started with the funny term of the test mushroom. It later continues with important guidelines how you can improve your testing first by optimizing your UI tests, then develop integration tests, and finally describing why unit testing is important to an organization, because of the Shift Left paradigm which involves developers into building quality to the application.  <hr data-astro-cid-bvzihdzo>  <h2 data-astro-cid-bvzihdzo>Related Posts</h2> <ul data-astro-cid-bvzihdzo> <li data-astro-cid-bvzihdzo> <a href="/cypress-vs-selenium-end-era/" data-astro-cid-bvzihdzo>Cypress vs. Selenium, is this the end of an era?</a> </li><li data-astro-cid-bvzihdzo> <a href="/soft-assertions-c-unit-testing-frameworks-mstest-nunit-xunit-net/" data-astro-cid-bvzihdzo>Soft assertions for C# unit testing frameworks (MSTest, NUnit, xUnit.net)</a> </li><li data-astro-cid-bvzihdzo> <a href="/soft-assertions-not-fail-junit-test/" data-astro-cid-bvzihdzo>Soft assertions that do not fail JUnit test</a> </li><li data-astro-cid-bvzihdzo> <a href="/efficient-waiting-for-ajax-call-data-loading-with-selenium-webdriver/" data-astro-cid-bvzihdzo>Efficient waiting for Ajax call data loading with Selenium WebDriver</a> </li><li data-astro-cid-bvzihdzo> <a href="/retry-junit-failed-tests-immediatelly/" data-astro-cid-bvzihdzo>Retry JUnit failed tests immediately</a> </li><li data-astro-cid-bvzihdzo> <a href="/net-core-integration-testing-mock-dependencies/" data-astro-cid-bvzihdzo>.NET Core integration testing and mock dependencies</a> </li><li data-astro-cid-bvzihdzo> <a href="/mock-stub-rest-api-wiremock-better-unit-testing/" data-astro-cid-bvzihdzo>Mock/Stub REST API with WireMock for better unit testing</a> </li><li data-astro-cid-bvzihdzo> <a href="/build-a-rest-stub-server-with-dropwizard/" data-astro-cid-bvzihdzo>Build a RESTful stub server with Dropwizard</a> </li><li data-astro-cid-bvzihdzo> <a href="/build-a-rest-api-with-net-core-2-and-run-it-on-docker-linux-container/" data-astro-cid-bvzihdzo>Build a REST API with .NET Core 2 and run it on Docker Linux container</a> </li><li data-astro-cid-bvzihdzo> <a href="/build-rest-api-express-node-js-run-docker/" data-astro-cid-bvzihdzo>Build a REST API with Express on Node.js and run it on Docker</a> </li><li data-astro-cid-bvzihdzo> <a href="/testing-with-cypress-lessons-learned-in-a-complete-framework/" data-astro-cid-bvzihdzo>Testing with Cypress - lessons learned in a complete framework</a> </li> </ul>  <div class="tags" data-astro-cid-bvzihdzo> <div data-astro-cid-bvzihdzo>Tags:</div> <a href="/tags/tutorials" data-astro-cid-bvzihdzo>Tutorials</a><a href="/tags/web-automation" data-astro-cid-bvzihdzo>Web Automation</a> </div> </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>