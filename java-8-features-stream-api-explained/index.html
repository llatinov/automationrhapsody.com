<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><script src="/scripts.js"></script><!-- Font preloads --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/java-8-features-stream-api-explained/"><!-- Primary Meta Tags --><title>Java 8 features - Stream API explained</title><meta name="title" content="Java 8 features - Stream API explained"><meta name="description" content="Code examples of Java 8 Stream API showing useful use cases."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/java-8-features-stream-api-explained/"><meta property="og:title" content="Java 8 features - Stream API explained"><meta property="og:description" content="Code examples of Java 8 Stream API showing useful use cases."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/java-8-features-stream-api-explained/"><meta property="twitter:title" content="Java 8 features - Stream API explained"><meta property="twitter:description" content="Code examples of Java 8 Stream API showing useful use cases."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:calc(100% - 2em);margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}pre{margin:0;padding:12px}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}.tab{overflow:hidden;border:1px solid #ccc;background-color:#f1f1f1}.tab button{background-color:inherit;float:left;border:none;outline:none;cursor:pointer;padding:14px 16px;transition:.3s}.tab button:hover{background-color:#ddd}.tab button.active{background-color:#ccc}.tabcontent{display:none;border-top:none}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
article[data-astro-cid-bvzihdzo]{padding:24px;box-shadow:0 2px 3px #acabab;background:#fff;position:relative}.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}.tags[data-astro-cid-bvzihdzo]{display:flex;flex-wrap:wrap}.tags[data-astro-cid-bvzihdzo]>a[data-astro-cid-bvzihdzo]{margin-left:8px}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 class="post-title" data-astro-cid-bvzihdzo>Java 8 features - Stream API explained</h1> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2017-06-21T00:00:00.000Z"> Jun 21, 2017 </time> </div> <hr data-astro-cid-bvzihdzo> </div>  <p>In <a href="/java-8-features-lambda-expressions-interface-changes-stream-api-datetime-api/">Java 8 features – Lambda expressions, Interface changes, Stream API, DateTime API</a> post I have briefly described most interesting Java 8 features. In the current post, I will give special attention to Stream API. This post is more theoretical which lays the foundation for next posts: <a href="/java-8-features-stream-api-basic-examples/">Java 8 features – Stream API basic examples</a> and <a href="/java-8-features-stream-api-advanced-examples/">Java 8 features – Stream API advanced examples</a> that gives code examples to explain the theory. Code examples here can be found in GitHub <a href="https://github.com/llatinov/java-samples/tree/master/java8" target="_blank" rel="noopener noreferrer">java-samples/java8</a> repository.</p>
<h2>Functional interfaces</h2>
Before explaining Stream API it is needed to understand the idea of a functional interface as they are leveraged for use with lambda expressions. A functional interface is an interface that has only one abstract method that is to be implemented. A functional interface may or may not have <em><strong>default</strong></em> or <em><strong>static</strong></em> methods. Although not mandatory, a good practice is to annotate a functional interface with <em><strong>@FunctionalInterface</strong></em>. Functional interfaces mostly used in Stream API operations are explained below. You can also use functional interfaces in a method signature, hence lambda expressions can be passed when calling a method. If one's below are not suitable you can always create own functional interface.
<h3>Predicate</h3>
Method for implementation is: <em><strong>boolean test(T t)</strong></em>. This interface is used in order to evaluate condition to an input object to a boolean expression.
<h3>Supplier</h3>
Method for implementation is: <em><strong>T get()</strong></em>. This interface is used in order to get output object as a result.
<h3>Function</h3>
Method for implementation is: <em><strong>R apply(T t)</strong></em>. This interface is used in order to produce a result object based on a given input object.
<h3>Consumer</h3>
Method for implementation is: <em><strong>void accept(T t)</strong></em>. This interface is used in order to do an operation on a single input object that does not produce any result.
<h3>BiConsumer</h3>
Method for implementation is: <em><strong>void accept(T t, U u)</strong></em>. This interface is used in order to do an operation on two input objects that do not produce any result.
<h2>Method reference</h2>
Sometimes when using lambda expression all that is done is calling a single method by name. Method reference provides an easy way to call the method making the code more readable. In short it is calling <em><strong>NumberUtils::isNumber</strong></em> instead of <em><strong>element-> NumberUtils.isNumber(element)</strong></em><span>.</span>
<h2>Stream API</h2>
Stream API is used for data processing which supports parallel operations. It enables data processing in a declarative way. Streams are sequences of elements that support different operations. Streams are lazily computed on demand when elements are needed. The stream is like a recipe that gets executed when actual result is needed.
<h2>Stream operations</h2>
Stream operations are divided into <em><strong>intermediate</strong></em> and <em><strong>terminal</strong></em> operations combined to form stream pipelines. Intermediate operations return a new stream. They are always lazy. Executing an intermediate operation such as <em><strong>filter()</strong></em> does not actually perform any filtering, but instead creates a new stream. Terminal operations on the other hand, such as <em><strong>collect()</strong></em> generates a result or final value. After the terminal operation is performed, the stream pipeline is considered consumed, and can no longer be used. Intermediate and terminal operators, such as <em><strong>limit()</strong></em> or <em><strong>findFirst()</strong></em> can be short-circuiting, once they achieve their goal they stop further stream processing. Intermediate operations are further divided into <em><strong>stateless</strong></em> and <em><strong>stateful</strong></em> operations. Stateless operations, such as <em><strong>filter()</strong></em> and <em><strong>map()</strong></em>, retain no state from the previously seen element when processing a new element, hence each element can be processed independently of operations on other elements. Stateful operations, such as <em><strong>distinct()</strong></em> and <em><strong>sorted()</strong></em>, may incorporate state from previously seen elements when processing new elements. For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream. As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data. Stateful operations should be carefully considered when constructing stream pipeline because they might require significant resources.
<h2>Stream API methods</h2>
Below is a list of most of the methods available in Stream interface with a short description. Code examples with explanations are in the following post.
<h3>filter</h3>
<em><strong>Stream filter(Predicate&#x3C;? super T> predicate)</strong></em> - a stateless intermediate operation that returns a stream consisting of the elements of this stream matching the given predicate.
<h3>map</h3>
<em><strong> Stream map(Function&#x3C;? super T, ? extends R> mapper)</strong></em> - a stateless intermediate operation that converts a value of one type into another by applying a function that does the conversion. Result is one output value for one input value.
<h3>distinct</h3>
<em><strong>Stream distinct()</strong></em> - stateful intermediate operation that removes duplicated elements using <em><strong>equals()</strong></em> method.
<h3>sorted</h3>
<em><strong>Stream sorted()</strong></em> or <em><strong>Stream sorted(Comparator&#x3C;? super T> comparator)</strong></em> - stateful intermediate operation that sorts stream elements according to given or default comparator.
<h3>peek</h3>
<em><strong>Stream peek(Consumer&#x3C;? super T> action)</strong></em> - a stateless intermediate operation that performs an action on an element once the stream is consumed. It does not change the stream or alter stream elements. It is mainly used for debugging purposes.
<h3>collect</h3>
<em><strong>&#x3C;R, A> R collect(Collector&#x3C;? super T, A, R> collector)</strong></em> or <em><strong> R collect(Supplier supplier, BiConsumer&#x3C;R, ? super T> accumulator, BiConsumer&#x3C;R, R> combiner)</strong></em> - terminal operation that performs mutable reduction operation on the stream elements reducing the stream to a mutable result collector, such as an <em><strong>ArrayList</strong></em>. Stream elements are incorporated into the result by updating it instead of replacing.
<h3>toArray</h3>
<em><strong>Object[] toArray()</strong></em> - terminal operation that returns array containing elements of this stream.
<h3>flatMap</h3>
<em><strong>&#x3C;R> Stream&#x3C;R> flatMap(Function&#x3C;? super T, ? extends Stream&#x3C;? extends R>> mapper)</strong></em> - stateless intermediate operation that replaces value with a stream. A result is an arbitrary number of output values to a single input value.
<h3>limit</h3>
<em><strong>Stream&#x3C;T> limit(long maxSize)</strong></em> - a short-circuiting stateful intermediate operation that truncates a stream to a given length.
<h3>skip</h3>
<em><strong>Stream&#x3C;T> skip(long n)</strong></em> - a stateful intermediate operation that skips first elements from a stream.
<h3>forEach</h3>
<em><strong>void forEach(Consumer&#x3C;? super T> action)</strong></em> - a terminal operation that performs an action for each element in the stream
<h3>reduce</h3>
<em><strong>T reduce(T identity, BinaryOperator&#x3C;T> accumulator)</strong></em> or <em><strong>Optional&#x3C;T> reduce(BinaryOperator&#x3C;T> accumulator)</strong></em> or <em><strong>&#x3C;U> U reduce(U identity, BiFunction&#x3C;U, ? super T, U> accumulator, BinaryOperator&#x3C;U> combiner)</strong></em> - terminal operation that performs reduction on the elements in the stream.
<h3>min</h3>
<em><strong> Optional&#x3C;T> min(Comparator&#x3C;? super T> comparator)</strong></em> - terminal operation that returns min element in stream based on given comparator. Special case of reduce operator.
<h3>max</h3>
<em><strong>Optional&#x3C;T> max(Comparator&#x3C;? super T> comparator)</strong></em> - terminal operation that returns max element in stream based on given comparator. Special case of reduce operator.
<h3>count</h3>
<em><strong>long count()</strong></em> - a terminal operation that counts elements in a stream.
<h3>anyMatch</h3>
<em><strong>boolean anyMatch(Predicate&#x3C;? super T> predicate)</strong></em> - a short-circuiting terminal operation that returns a boolean result if an element in stream conforms to given predicate. Once the result is true operation is cancelled and the result is returned.
<h3>allMatch</h3>
<em><strong>boolean allMatch(Predicate&#x3C;? super T> predicate)</strong></em> - a short-circuiting terminal operation that returns a boolean result if all elements in stream conforms to given predicate. Once the result is false operation is cancelled and the result is returned.
<h3>noneMatch</h3>
<em><strong> boolean noneMatch(Predicate&#x3C;? super T> predicate)</strong></em> - a short-circuiting terminal operation that returns a boolean result if none elements in stream conform to given predicate. Once the result is false operation is cancelled and the result is returned.
<h3>findFirst</h3>
<em><strong> Optional&#x3C;T> findFirst()</strong></em> - a short-circuiting terminal operation that returns an <em><strong>Optional</strong></em> with the first element of this stream or an empty <em><strong>Optional</strong></em> if the stream is empty. If the stream has no order, such as <em><strong>Map</strong></em> or <em><strong>Set</strong></em>, then any element may be returned.
<h3>findAny</h3>
<em><strong>Optional&#x3C;T> findAny()</strong></em>  - a short-circuiting terminal operation that returns an <em><strong>Optional</strong></em> with some element of the stream or an empty <em><strong>Optional</strong></em> if the stream is empty.
<h2>Conclusion</h2>
Stream API is very powerful instrument provided in Java 8. They allow data processing in a declarative way and in parallel. Code looks very neat and easy to read.  <hr data-astro-cid-bvzihdzo>  <h2 data-astro-cid-bvzihdzo>Related Posts</h2> <ul data-astro-cid-bvzihdzo> <li data-astro-cid-bvzihdzo> <a href="/java-8-features-lambda-expressions-interface-changes-stream-api-datetime-api/" data-astro-cid-bvzihdzo>Java 8 features - Lambda expressions, Interface changes, Stream API, DateTime API</a> </li><li data-astro-cid-bvzihdzo> <a href="/java-8-features-stream-api-advanced-examples/" data-astro-cid-bvzihdzo>Java 8 features - Stream API advanced examples</a> </li><li data-astro-cid-bvzihdzo> <a href="/java-8-features-stream-api-basic-examples/" data-astro-cid-bvzihdzo>Java 8 features - Stream API basic examples</a> </li> </ul>  <div class="tags" data-astro-cid-bvzihdzo> <div data-astro-cid-bvzihdzo>Tags:</div> <a href="/tags/java" data-astro-cid-bvzihdzo>Java</a><a href="/tags/java8" data-astro-cid-bvzihdzo>Java 8</a><a href="/tags/tutorials" data-astro-cid-bvzihdzo>Tutorials</a> </div> </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>