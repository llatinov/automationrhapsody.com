<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><script src="/scripts.js"></script><!-- Font preloads --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/distributed-system-observability-extract-and-visualize-metrics-from-opentelemetry-spans/"><!-- Primary Meta Tags --><title>Distributed system observability: extract and visualize metrics from OpenTelemetry spans</title><meta name="title" content="Distributed system observability: extract and visualize metrics from OpenTelemetry spans"><meta name="description" content="How to extract metrics from spans by OpenTelementry collector, store them in Prometheus and properly visualize them in Grafana."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/distributed-system-observability-extract-and-visualize-metrics-from-opentelemetry-spans/"><meta property="og:title" content="Distributed system observability: extract and visualize metrics from OpenTelemetry spans"><meta property="og:description" content="How to extract metrics from spans by OpenTelementry collector, store them in Prometheus and properly visualize them in Grafana."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/distributed-system-observability-extract-and-visualize-metrics-from-opentelemetry-spans/"><meta property="twitter:title" content="Distributed system observability: extract and visualize metrics from OpenTelemetry spans"><meta property="twitter:description" content="How to extract metrics from spans by OpenTelementry collector, store them in Prometheus and properly visualize them in Grafana."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:calc(100% - 2em);margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}pre{margin:0;padding:12px}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}.tab{overflow:hidden;border:1px solid #ccc;background-color:#f1f1f1}.tab button{background-color:inherit;float:left;border:none;outline:none;cursor:pointer;padding:14px 16px;transition:.3s}.tab button:hover{background-color:#ddd}.tab button.active{background-color:#ccc}.tabcontent{display:none;border-top:none}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
article[data-astro-cid-bvzihdzo]{padding:24px;box-shadow:0 2px 3px #acabab;background:#fff;position:relative}.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}.tags[data-astro-cid-bvzihdzo]{display:flex;flex-wrap:wrap}.tags[data-astro-cid-bvzihdzo]>a[data-astro-cid-bvzihdzo]{margin-left:8px}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 class="post-title" data-astro-cid-bvzihdzo>Distributed system observability: extract and visualize metrics from OpenTelemetry spans</h1> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2021-11-19T00:00:00.000Z"> Nov 19, 2021 </time> </div> <hr data-astro-cid-bvzihdzo> </div>  <p>This post is part of <a href="/distributed-system-observability-complete-end-to-end-example-with-opentracing-jaeger-prometheus-grafana-spring-boot-react-and-selenium/">Distributed system observability: complete end-to-end example</a> series. The code used for this series of blog posts is located in <a href="https://github.com/llatinov/selenium-observability-java" target="_blank" rel="noopener noreferrer">selenium-observability-java</a> GitHub repository.</p>
<h2>Prometheus and metrics</h2>
<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> is an open-source monitoring and alerting toolkit. Prometheus collects and stores its metrics. Metrics information is stored with the timestamp at which it was recorded, alongside optional key-value pairs called labels. Metric is a way to measure something, e.g. how many people had read the current article. Metrics change over time, and Prometheus is recording and graphically visualizing the change over time.
<h2>Extract metrics from spans in OpenTelementry Collector</h2>
<a href="https://github.com/open-telemetry/opentelemetry-collector" target="_blank" rel="noopener">OpenTelemetry collector</a> receives tracing data from the frontend, converts it into Jaeger format, and exports it to the Jaeger backend. Every span has duration, which is a metric. In order to extract the metric, the <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/spanmetricsprocessor" target="_blank" rel="noopener">Span Metrics Processor contributors library</a> is used. Full configurations are in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/otel-config.yaml" target="_blank" rel="noopener">otel-config.yaml</a>. In the file are configured <em><strong>receivers</strong></em>, <em><strong>processors</strong></em>, <em><strong>exporters,</strong></em> and <em><strong>service</strong></em>, There are two receivers: <em><strong>oltp</strong></em> is receiving the traces; <em><strong>otlp/spanmetrics</strong></em> is a dummy receiver, that is never used, but the pipeline requires one to be present. There are two processors: <em><strong>batch</strong></em> compresses the data into batches and optimizes data transmission; <em><strong>spanmetrics</strong></em> extracts the metrics from spans. Spanmetrics configuration should have <em><strong>metrics_exporter</strong></em>, <em><strong>prometheus</strong></em> in the current case, which is existing in the <em><strong>exporters</strong></em> section of the configuration. An optional configuration is <em><strong>latency_histogram_buckets</strong></em>, which defines the histogram buckets. This is a very important concept and will be explained later. There are two exporters: <em><strong>jaeger</strong></em> sends the data to Jaeger backend; <em><strong>prometheus</strong></em> defines an endpoint, which Prometheus can fetch the metrics from, <em><strong>0.0.0.0:8889</strong></em> in the current example. Port <em><strong>8889</strong></em> also has to be exposed in <em><strong>docker-compose.yml</strong></em> file. The <em><strong>service</strong></em> section is used to configure what components are enabled. In the current example, <em><strong>otlp</strong></em> receiver takes the traces and exports them to <em><strong>jaeger</strong></em>, also traces are being processed by <em><strong>spanmetrics</strong></em> processor and exported as metrics to <em><strong>prometheus</strong></em> endpoint. More details can be found in <a href="https://opentelemetry.io/docs/collector/configuration/" target="_blank" rel="noopener">OpenTelemetry Collector configuration</a>.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>receivers:</span></span>
<span class="line"><span>  otlp:</span></span>
<span class="line"><span>    protocols:</span></span>
<span class="line"><span>      grpc:</span></span>
<span class="line"><span>      http:</span></span>
<span class="line"><span>  otlp/spanmetrics:</span></span>
<span class="line"><span>    protocols:</span></span>
<span class="line"><span>      grpc:</span></span>
<span class="line"><span>        endpoint: 0.0.0.0:12346</span></span>
<span class="line"><span></span></span>
<span class="line"><span>processors:</span></span>
<span class="line"><span>  batch:</span></span>
<span class="line"><span>  spanmetrics:</span></span>
<span class="line"><span>    metrics_exporter: prometheus</span></span>
<span class="line"><span>    latency_histogram_buckets:</span></span>
<span class="line"><span>      [200ms, 400ms, 800ms, 1s, 1200ms, 1400ms, 1600ms, 1800ms, 2s, 5s, 7s]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exporters:</span></span>
<span class="line"><span>  jaeger:</span></span>
<span class="line"><span>    endpoint: jaeger:14250</span></span>
<span class="line"><span>    tls:</span></span>
<span class="line"><span>      insecure: true</span></span>
<span class="line"><span>  prometheus:</span></span>
<span class="line"><span>    endpoint: 0.0.0.0:8889</span></span>
<span class="line"><span>    metric_expiration: 1440m</span></span>
<span class="line"><span></span></span>
<span class="line"><span>service:</span></span>
<span class="line"><span>  pipelines:</span></span>
<span class="line"><span>    traces:</span></span>
<span class="line"><span>      receivers: [otlp]</span></span>
<span class="line"><span>      processors: [spanmetrics, batch]</span></span>
<span class="line"><span>      exporters: [jaeger]</span></span>
<span class="line"><span>    metrics:</span></span>
<span class="line"><span>      receivers: [otlp/spanmetrics]</span></span>
<span class="line"><span>      exporters: [prometheus]</span></span>
<span class="line"><span></span></span></code></pre>
<h2>Prometheus histogram by OpenTelemetry Collector</h2>
A <a href="https://prometheus.io/docs/concepts/metric_types/#histogram" target="_blank" rel="noopener">Prometheus histogram</a> collects metrics and counts them in configurable buckets. It also provides a sum of all observed values. Buckets are separate measurable dimensions that metrics are put into. In the current example, the buckets are <em><strong>[200ms, 400ms, 800ms, 1s, 1200ms, 1400ms, 1600ms, 1800ms, 2s, 5s, 7s]</strong></em>. Spans that are being received by the frontend are compared by their duration and put into a separate metric bucket. The easiest way to illustrate this is with an example. If a request takes 1.29 seconds, then buckets from 200ms to 1200ms are untouched, all other buckets from 1400ms to 7s are increased with a value of 1. When the next request comes with a duration of 1.99 seconds, then buckets from 200ms to 1800ms are untouched, buckets from 2s to 7s are increased with a value of 1. This is hard to understand but is a very important concept. You can experiment by running the examples, then open the frontend at <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a>, and click the "<span>Fetch persons</span>" button. Observe the metrics buckets at OpenTelemetry Collector <a href="http://localhost:8889/metrics" target="_blank" rel="noopener">http://localhost:8889/metrics</a>. The metrics of the two example requests above are visialized in the screenshot below. Buckets are with name <em><strong>latency_bucket</strong></em> and additional labels to identify the correct span. The span name is set into the <em><strong>operation</strong></em> label in the bucket. In the current example, <em><strong>"GET /api/person-service/persons"</strong></em> span is used. Along with the configured buckets, there are two additional buckets - <em><strong>9.223372036854775e+12</strong></em> - I truly do not what that is, and <em><strong>+Inf</strong></em> - this is the default bucket for all requests which does not fit the predefined buckets, i.e. longer than 7 seconds. There are two more counters - <em><strong>latency_sum</strong></em> - the total time in milliseconds that all the requests took, in our case - 1.29s + 1.99s = 3279ms; <em><strong>latency_count</strong></em> - the total number of requests, in our case - 2.
<p><a href="/images/2021/11/Selenium-Observability-otel-collector-buckets.png"><img src="/images/2021/11/Selenium-Observability-otel-collector-buckets.png"></a></p>
<h2>Visualize in Grafana</h2>
The two requests listed above are visualized in Grafana as shown below, one request is in the 1400ms (1200ms-1400ms) bucket, one request is in the 2000ms (1800ms-2000ms) bucket.
<img src="/images/2021/11/Selenium-Observability-Grafana-buckets.png">
<p>The panel above is defined in Grafana. It is a <em><strong>Bar gauge</strong></em>, the data source is <em><strong>Prometheus</strong></em>, Metric browser is <em><strong>latency_bucket{operation=“GET /api/person-service/persons”,service_name=“person-service-frontend”,span_kind=“SPAN_KIND_CLIENT”,status_code=“STATUS_CODE_UNSET”}</strong></em>, Legend is <em><strong>{{le}}</strong></em>, Min step is <em><strong>1</strong></em>, Format is <em><strong>Heatmap</strong></em>.</p>
<p><a href="/images/2021/11/Selenium-Observability-Grafana-panel.png"><img src="/images/2021/11/Selenium-Observability-Grafana-panel.png"></a></p>
<p>Working with histogram buckets is a complex task, <a href="https://grafana.com/blog/2020/06/23/how-to-visualize-prometheus-histograms-in-grafana/" target="_blank" rel="noopener">How to visualize Prometheus histograms in Grafana</a> post gives good guidance.</p>
<p>A custom dashboard is created in the examples, it is accessible at <a href="http://localhost:3001/d/bgZ6Mf5nk/fetch-persons?orgId=1" target="_blank" rel="noopener"></a><a href="http://localhost:3001/d/bgZ6Mf5nk/fetch-persons?orgId=1">http://localhost:3001/d/bgZ6Mf5nk/fetch-persons?orgId=1</a>. The dashboard is defined in <a href="https://github.com/llatinov/selenium-observability-java/blob/main/etc/grafana-custom-dashboard.json" target="_blank" rel="noopener">etc/grafana-custom-dashboard.json</a> file.</p>
<p><a href="/images/2021/11/Selenium-Observability-Grafana-dashboard.png"><img src="/images/2021/11/Selenium-Observability-Grafana-dashboard.png"></a></p>
<h2>Conclusion</h2>
In the current post, I have shown how to make OpenTelemetry Collector convert the spans into metrics, which can be fetched by Prometheus and visualized in Grafana.  <hr data-astro-cid-bvzihdzo>  <h2 data-astro-cid-bvzihdzo>Related Posts</h2> <ul data-astro-cid-bvzihdzo> <li data-astro-cid-bvzihdzo> <a href="/distributed-system-observability-complete-end-to-end-example-with-opentracing-jaeger-prometheus-grafana-spring-boot-react-and-selenium/" data-astro-cid-bvzihdzo>Distributed system observability: complete end-to-end example with OpenTracing, Jaeger, Prometheus, Grafana, Spring Boot, React and Selenium</a> </li> </ul>  <div class="tags" data-astro-cid-bvzihdzo> <div data-astro-cid-bvzihdzo>Tags:</div> <a href="/tags/grafana" data-astro-cid-bvzihdzo>Grafana</a><a href="/tags/opentelemetry" data-astro-cid-bvzihdzo>OpenTelemetry</a><a href="/tags/prometheus" data-astro-cid-bvzihdzo>Prometheus</a><a href="/tags/tutorials" data-astro-cid-bvzihdzo>Tutorials</a> </div> </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>