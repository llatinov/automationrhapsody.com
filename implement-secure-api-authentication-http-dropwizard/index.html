<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><!-- Font preloads --><!-- <link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin /> --><!-- <link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin /> --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/implement-secure-api-authentication-http-dropwizard/"><!-- Primary Meta Tags --><title>Implement secure API authentication over HTTP with Dropwizard</title><meta name="title" content="Implement secure API authentication over HTTP with Dropwizard"><meta name="description" content="Reference implementation on suggested in <a href=&#34;/implement-secure-rest-api-authentication-http/&#34;>How to implement secure REST API authentication over HTTP</a> post authentication mechanism."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/implement-secure-api-authentication-http-dropwizard/"><meta property="og:title" content="Implement secure API authentication over HTTP with Dropwizard"><meta property="og:description" content="Reference implementation on suggested in <a href=&#34;/implement-secure-rest-api-authentication-http/&#34;>How to implement secure REST API authentication over HTTP</a> post authentication mechanism."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder-1.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/implement-secure-api-authentication-http-dropwizard/"><meta property="twitter:title" content="Implement secure API authentication over HTTP with Dropwizard"><meta property="twitter:description" content="Reference implementation on suggested in <a href=&#34;/implement-secure-rest-api-authentication-http/&#34;>How to implement secure REST API authentication over HTTP</a> post authentication mechanism."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder-1.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:calc(100% - 2em);margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
article[data-astro-cid-bvzihdzo]{padding:24px;box-shadow:0 2px 3px #acabab;background:#fff;position:relative}.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2016-07-08T00:00:00.000Z"> Jul 8, 2016 </time> <div class="last-updated-on" data-astro-cid-bvzihdzo>
Last updated on <time datetime="2022-01-18T00:00:00.000Z"> Jan 18, 2022 </time> </div> </div> <h1 class="post-title" data-astro-cid-bvzihdzo>Implement secure API authentication over HTTP with Dropwizard</h1> <hr data-astro-cid-bvzihdzo> </div>  <h2>API authentication mechanism</h2>
Suggested authentication mechanism consists of following steps:
<ul>
 	<li>The secret key that is known only by API consumer and API provider is needed along with API key.</li>
 	<li>The secret key is used to one way hash a token which is sent to the server along with API key in the API call.</li>
 	<li>Token consists of API key + Secret key + Current time in seconds, which then gets hashed with SHA-256 algorithm preferably.</li>
 	<li>Server recreates all the tokens locally for every second for some time in the future, preferably not too long - 30~120 seconds.</li>
 	<li>Server recreates all the tokens for 30~120 seconds in the past, to take into account the time needed for a request to reach the server.</li>
 	<li>The server compares each of the tokens with received one.</li>
 	<li>If there is match consumer is authenticated and a response is returned.</li>
</ul>
<h2>Dropwizard implementation</h2>
Dropwizard stub introduced in <a href="/build-a-rest-stub-server-with-dropwizard/">Build a RESTful stub server with Dropwizard</a> post will be used to create authentication. The full example can be found in GitHub <a href="https://github.com/llatinov/sample-dropwizard-rest-stub" target="_blank" rel="noopener noreferrer">sample-dropwizard-rest-stub</a> repository. The implementation consists of following steps:
<ul>
 	<li>Implement <em><strong>javax.ws.rs.container.ContainerRequestFilter</strong></em> interface. Implementation will inspect every request and verify authentication.</li>
 	<li>Create custom annotation</li>
 	<li>Annotate RequestFilter and Dropwizard resource (API service) on which authentication should be applied.</li>
 	<li>Register RequestFilter implementation class into Dropwizard Jersey environment.</li>
</ul>
<h2>Create custom annotation</h2>
Starting with the easiest step. Creating custom annotation is pretty easy. It could be applied to a class (<em><strong>ElementType.TYPE</strong></em>) or to a method (<em><strong>ElementType.METHOD</strong></em>). It should live as long as program runs (<em><strong>RetentionPolicy.RUNTIME</strong></em>). In order to make it possible annotated request filter to be applied to a specific resource, only <em><strong>@NameBinding</strong></em> annotation is a must in Jersey. If not specified request filter will apply to all resources. Needed annotation is:
<pre class="language-java"><code>import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.ws.rs.NameBinding;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
@NameBinding
public @interface Authenticator {
}
</code></pre>
<h2>ContainerRequestFilter implementation</h2>
Container request filter is applied to incoming requests. If used with <em><strong>@NameBinding</strong></em> annotation it is applied only where needed, if not it is applied globally. Mandatory is to override <em><strong>filter()</strong></em> method:
<pre class="language-java"><code>import com.automationrhapsody.reststub.persistence.AuthDB;

import java.io.IOException;
import java.util.List;

import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

@Authenticator
public class AuthenticateFilter implements ContainerRequestFilter {

	private static final String PARAM_API_KEY = "apiKey";
	private static final String PARAM_TOKEN = "token";
	private static final long SECONDS_IN_MILLISECOND = 1000L;
	private static final int TTL_SECONDS = 60;

	@Override
	public void filter(ContainerRequestContext context) throws IOException {
		final String apiKey = extractParam(context, PARAM_API_KEY);
		if (StringUtils.isEmpty(apiKey)) {
			context.abortWith(responseMissingParameter(PARAM_API_KEY));
		}

		final String token = extractParam(context, PARAM_TOKEN);
		if (StringUtils.isEmpty(token)) {
			context.abortWith(responseMissingParameter(PARAM_TOKEN));
		}

		if (!authenticate(apiKey, token)) {
			context.abortWith(responseUnauthorized());
		}
	}
}
</code></pre>
<p>As seen above two GET parameters are mandatory in the request: <em><strong>“apiKey”</strong></em> and <em><strong>“token”</strong></em>. Those are first extracted and verified. If some of them are not existing <em><strong>BAD_REQUEST</strong></em> (HTTP Status code 400) <em><strong>Response</strong></em> is returned with an error message. Methods that extract params and build error response are:</p>
<pre class="language-java"><code>private String extractParam(ContainerRequestContext context, String param) {
	final UriInfo uriInfo = context.getUriInfo();
	final List user = uriInfo.getQueryParameters().get(param);
	return CollectionUtils.isEmpty(user) ? null : String.valueOf(user.get(0));
}

private Response responseMissingParameter(String name) {
	return Response.status(Response.Status.BAD_REQUEST)
		.type(MediaType.TEXT_PLAIN_TYPE)
		.entity("Parameter '" + name + "' is required.")
		.build();
}
</code></pre>
<p>If both are present then code tried to authenticate the call by rebuilding all the hashes for 60 seconds in the past because the request cannot arrive instantly it takes some time. If the network is slower this time can be increased. It also rebuilds all hashes for 60 seconds in the future, this is token’s time to live. The server has access to the Secret key for any given API key. In the example above they are stored in fake DB provider and obtained by <em><strong>AuthDB.getSecretKey(apiKey)</strong></em>:</p>
<pre class="language-java"><code>private boolean authenticate(String apiKey, String token) {
	final String secretKey = AuthDB.getSecretKey(apiKey);

	// No need to calculate digest in case of wrong apiKey
	if (StringUtils.isEmpty(secretKey)) {
		return false;
	}

	final long nowSec = System.currentTimeMillis() / SECONDS_IN_MILLISECOND;
	long startTime = nowSec - TTL_SECONDS;
	long endTime = nowSec + TTL_SECONDS;
	for (; startTime &#x3C; endTime; startTime++) {
		final String toHash = apiKey + secretKey + startTime;
		final String sha1 = DigestUtils.sha256Hex(toHash);
		if (sha1.equals(token)) {
			return true;
		}
	}

	return false;
}
</code></pre>
<p>As seen above server uses SHA-256 cryptographic algorithm. It is the best solution in terms of speed and security. In <a href="/md5-sha-1-sha-256-sha-512-speed-performance/">MD5, SHA-1, SHA-256 and SHA-512 speed performance</a> post a comparison between MD5, SHA-1, SHA-256, and SHA-512 is made. If authentication cannot be verified then <em><strong>UNAUTHORIZED</strong></em> (HTTP Status code 401) <em><strong>Response</strong></em> response is returned:</p>
<pre class="language-java"><code>private Response responseUnauthorized() {
	return Response.status(Response.Status.UNAUTHORIZED)
		.type(MediaType.TEXT_PLAIN_TYPE)
		.entity("Unauthorized")
		.build();
}
</code></pre>
<p>This is the hardest part. Now, this filter has to be registered with Jersey and applied to needed resources (services). See more on <em><strong>ContainerRequestFilter</strong></em> interface and <em><strong>@NameBinding</strong></em> annotation in <a href="https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest/filters-and-interceptors.html" target="_blank" rel="noopener noreferrer">Jersey filters and interceptors</a> page.</p>
<h2>Apply authentication filter on a resource</h2>
Indicating that given resource should be checked for authentication is done with custom <em><strong>@Authenticator</strong></em> annotation created previously. If needed just for specific API call it can be applied also on a method level:
<pre class="language-java"><code>import com.automationrhapsody.reststub.data.Book;
import com.automationrhapsody.reststub.filters.Authenticator;
import com.automationrhapsody.reststub.persistence.BookDB;
import com.codahale.metrics.annotation.Timed;

import java.util.List;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Authenticator
@Path("/secure/books")
public class BooksSecureService {

	@GET
	@Timed
	@Produces(MediaType.APPLICATION_JSON)
	public List&#x3C;Book> getBooks() {
		return BookDB.getAll();
	}
}
</code></pre>
<h2>Register in Dropwizard Jersey</h2>
The last step is to register the request filter and resource with Dropwizard's Jersey:
<pre class="language-java"><code>@Override
public void run(RestStubConfig config, Environment env) {

	env.jersey().register(BooksSecureService.class);
	env.jersey().register(AuthenticateFilter.class);

}
</code></pre>
<h2>Conclusion</h2>
Very easy to implement in Dropwizard and a relatively secure way to provide API authentication over HTTP protocol. For a mission-critical application, definitely more strict consideration and review of this authentication mechanism are needed.  </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>