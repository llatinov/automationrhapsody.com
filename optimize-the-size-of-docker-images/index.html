<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Automation Rhapsody" href="https://automationrhapsody.com/rss.xml"><meta name="generator" content="Astro v5.5.3"><script src="/scripts.js"></script><!-- Font preloads --><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Playball"><link rel="stylesheet" property="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,400italic,700"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://automationrhapsody.com/optimize-the-size-of-docker-images/"><!-- Primary Meta Tags --><title>Optimize the size of Docker images</title><meta name="title" content="Optimize the size of Docker images"><meta name="description" content="How to optimize the size of the Docker images, by using intermediate build image and final runtime image."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://automationrhapsody.com/optimize-the-size-of-docker-images/"><meta property="og:title" content="Optimize the size of Docker images"><meta property="og:description" content="How to optimize the size of the Docker images, by using intermediate build image and final runtime image."><meta property="og:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://automationrhapsody.com/optimize-the-size-of-docker-images/"><meta property="twitter:title" content="Optimize the size of Docker images"><meta property="twitter:description" content="How to optimize the size of the Docker images, by using intermediate build image and final runtime image."><meta property="twitter:image" content="https://automationrhapsody.com/blog-placeholder.jpg"><style>:root{--color-gray-bg: #f5f5f5;--color-gray-text: #5e5e5e}body{font-family:Roboto,sans-serif;background:var(--color-gray-bg);word-wrap:break-word;overflow-wrap:break-word;color:var(--color-gray-text);font-size:18px}main{width:960px;max-width:100%;margin:auto}h2{color:#3879d9;font-size:20px;margin:25px 0 6px}p{margin:6px 0}img{max-width:100%}pre{margin:0;padding:12px}.card{padding:16px;margin:10px;box-shadow:0 2px 3px #acabab;background:#fff;border-radius:24px;color:inherit}@media (max-width: 720px){body{font-size:16px}ul{padding-inline-start:16px}}.tab{overflow:hidden;border:1px solid #ccc;background-color:#f1f1f1}.tab button{background-color:inherit;float:left;border:none;outline:none;cursor:pointer;padding:14px 16px;transition:.3s}.tab button:hover{background-color:#ddd}.tab button.active{background-color:#ccc}.tabcontent{display:none;border-top:none}footer[data-astro-cid-sz7xmlte]{margin:24px 0;text-align:center}header[data-astro-cid-3ef6ksr2]{text-align:center;font-size:56px}header[data-astro-cid-3ef6ksr2] div[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{font-family:Playball,Arial;color:#000;text-decoration:none;text-shadow:0 .033em 0 #fff;border-bottom:none}
.post-title[data-astro-cid-bvzihdzo]{font-family:Bitter,serif;font-weight:700!important;margin:0;padding:5px 0;font-size:32px;line-height:40px;color:#444}.tags[data-astro-cid-bvzihdzo]{display:flex;flex-wrap:wrap}.tags[data-astro-cid-bvzihdzo]>a[data-astro-cid-bvzihdzo]{margin-left:8px}@media (max-width: 720px){article[data-astro-cid-bvzihdzo]{padding:12px}}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <div data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2>Automation Rhapsody</a> </div> </header>  <main data-astro-cid-bvzihdzo> <article class="card" data-astro-cid-bvzihdzo> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 class="post-title" data-astro-cid-bvzihdzo>Optimize the size of Docker images</h1> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2019-12-03T00:00:00.000Z"> Dec 3, 2019 </time> </div> <hr data-astro-cid-bvzihdzo> </div>  <p><span>The code used for this blog post is located </span><span>in </span><a href="https://github.com/llatinov/dotnet.core.templates" target="_blank" rel="noopener noreferrer">dotnet.core.templates</a><span> GitHub repository. The code examples below are for .NET Core 3.0, but principles applied in this article are valid for any programming language, so it is worth reading.</span></p>
<h2>Docker layers and images</h2>
Docker image is an executable version of a given application that runs on top of an operating system's kernel. Docker image is the result of the execution of a Dockerfile. Usually, Dockerfile starts from some base image, for e.g. an operating system. Then commands are built on top of this base image and the result is a new image. This new image can be used as a base image somewhere else. Each and every command in Dockerfile results in a layer. This layering system is used for better reusability, as several images can reuse a given layer. The more layers are added to the image the bigger it gets in size.
<p>All docker images can be listed with <em><strong>docker images</strong></em> command. Size is also present as an output of the command. Then for a given image, it is possible to list all the layers with <em><strong>docker history &#x3C;IMAGE_NAME></strong></em> command, which also shows the size of a given layer.</p>
<p>Images are kept in a Docker repository, either public or private. The bigger the image, the more time it takes to upload, to download and the more space it consumes in the repository. It is a good practice to optimize the images in terms of size.</p>
<h2>Optimize the size</h2>
Usually when building software much more resources are needed, such as SDK, or compiler, or additional libraries, than if the software is run. One strategy for optimization is to build the software on a special build machine and then pack it to a Docker image. In this approach, the build machine should have the needed build software. This puts some demand on the build machine and also makes the image creating process dependant on certain software packages being installed. A more convenient option is to build the application as part of the Docker image creating and then packet into a separate container. See Dockerfile below.
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim AS base</span></span>
<span class="line"><span>WORKDIR /app</span></span>
<span class="line"><span></span></span>
<span class="line"><span>FROM mcr.microsoft.com/dotnet/core/sdk:3.0-buster AS build</span></span>
<span class="line"><span>WORKDIR /src</span></span>
<span class="line"><span>COPY . .</span></span>
<span class="line"><span>RUN dotnet restore</span></span>
<span class="line"><span>RUN dotnet publish -c Release -o /pub</span></span>
<span class="line"><span></span></span>
<span class="line"><span>FROM base AS final</span></span>
<span class="line"><span>WORKDIR /app</span></span>
<span class="line"><span>COPY --from=build /pub .</span></span>
<span class="line"><span>ENTRYPOINT ["dotnet", "PROJECT_NAME.dll"]</span></span>
<span class="line"><span></span></span></code></pre>
<p>In short, image <em><strong>sdk:3.0-buster</strong></em> is used to publish the application as it has .NET Core SDK on it, and then application code is copied into <em><strong>aspnet:3.0-buster-slim</strong></em> which has only the .NET Core runtime and is low in size.</p>
<p>No matter how the software is built, the most optimal image in terms of size and capabilities has to be selected to pack the code into. For e.g. Google provides <a href="https://github.com/GoogleContainerTools/distroless" target="_blank" rel="noopener noreferrer">“Distroless”</a>, images that <span>do not contain package managers, shells or any other programs you would expect to find in a standard Linux distribution. This makes images smaller and much more secure. </span><span>I tried to build the application I am experimenting with into Distroless image and it gets 136MB in size, where if I pack it into .NET 3.0 runtime image it gets 209MB. Unfortunately, there is no Distroless image for .NET Core 3.0, so my experiment image fails to run, and I have to use <em><strong>aspnet:3.0-buster-slim</strong></em> in order to run my sample application.</span></p>
<h2>.NET Core different images</h2>
.NET Core has different images, which are very well explained into <a href="https://hub.docker.com/_/microsoft-dotnet-core-sdk/" target="_blank" rel="noopener noreferrer">.NET Core SDK images</a> page. They are:
<ul>
 	<li><span>buster - Debian 10</span></li>
 	<li><span>alpine - Alpine</span></li>
 	<li><span>bionic - Ubuntu 18.04</span></li>
 	<li><span>disco - Ubuntu 19.04</span></li>
 	<li><span>stretch - Debian 9</span></li>
</ul>
<h2>.NET Core 3.0 error in stretch images</h2>
This section is not directly contributing to the main point of the topic, but it might be helpful to someone. When I experimented, I initially started with <em><strong>stretch</strong></em> base images. And I got the following errors:
<ul>
 	<li><em><strong>System.MissingMethodException: Method not found: 'Void Microsoft.AspNetCore.WebUtilities.FileBufferingReadStream..ctor(System.IO.Stream, Int32)'</strong></em></li>
 	<li><em><strong>System.TypeLoadException: Could not load type 'Microsoft.AspNetCore.WebUtilities</strong></em></li>
</ul>
These errors were not present when switching to <em><strong>buster</strong></em> base images.
<h2>Conclusion</h2>
In the current post, I describe how to construct Docker files so the build is done in Docker, eliminating the need of having specific software in order to pack the images. No matter how the software is built it is very important to pack it into the smallest possible image in order to save bandwidth and storage space during image usage. Google provides Distroless<span> images that seem very lightweight and also secure as they do not contain package managers, shells or any other programs. Examples in this post are in .NET Core 3.0, but principles can be applied to different programming languages and technologies.</span>  <hr data-astro-cid-bvzihdzo>  <h2 data-astro-cid-bvzihdzo>Related Posts</h2> <ul data-astro-cid-bvzihdzo> <li data-astro-cid-bvzihdzo> <a href="/dockerize-react-application-with-a-docker-multi-staged-build/" data-astro-cid-bvzihdzo>Dockerize React application with a Docker multi-staged build</a> </li> </ul>  <div class="tags" data-astro-cid-bvzihdzo> <div data-astro-cid-bvzihdzo>Tags:</div> <a href="/tags/dotnet-core" data-astro-cid-bvzihdzo>.NET Core</a><a href="/tags/docker" data-astro-cid-bvzihdzo>Docker</a><a href="/tags/tutorials" data-astro-cid-bvzihdzo>Tutorials</a> </div> </div> </article> </main> <footer data-astro-cid-sz7xmlte>
&copy; 2025 - Automation Rhapsody. All rights reserved.
</footer>  </body></html>